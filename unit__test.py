"""
@file test_reti_full.py
@brief Unit Testing Suite for the Retinal Game.
@details This file contains a comprehensive set of unit tests covering 
         Helper functions, Localization, Theme management, Economy systems, 
         Game Objects, Physics, UI, and State transitions.
         It utilizes `unittest.mock` to simulate Pygame interactions, allowing
         headless testing (CI/CD friendly).

@author Generated by AI
@version 2.0
@date 2025
"""

import unittest
from unittest.mock import MagicMock, patch
import sys
import os

# --- 1. MOCKING PYGAME ---
# @details We mock the pygame module BEFORE importing the game to prevent 
#          video drivers or audio devices from initializing during tests.
mock_pygame = MagicMock()
mock_pygame.Rect = MagicMock
sys.modules['pygame'] = mock_pygame
sys.modules['pygame.mixer'] = MagicMock()
sys.modules['pygame.font'] = MagicMock()
sys.modules['pygame.display'] = MagicMock()
sys.modules['pygame.time'] = MagicMock()
sys.modules['pygame.event'] = MagicMock()
sys.modules['pygame.image'] = MagicMock()
sys.modules['pygame.transform'] = MagicMock()

# --- 2. IMPORT GAME ---
import reti

class TestRetinalMegaSuite(unittest.TestCase):
    """
    @class TestRetinalMegaSuite
    @brief The main test suite class inheriting from unittest.TestCase.
    @details Contains 55 tests covering all major subsystems of the game.
    """

    def setUp(self):
        """
        @brief Pre-test initialization.
        @details Sets up a headless Game instance, resets localization to English,
                 resets the theme to 'dark', and populates game data with test values.
        """
        # Start game in "headless" mode (no window)
        self.game = reti.Game(headless=True)
        
        # Reset globals
        reti.loc.current_lang = "EN"
        reti.theme_mgr.current_theme = "dark"
        
        # Reset player data
        self.game.data = {
            "high_score": 0,
            "currency": 1000,
            "inventory": ["Default", "Star", "Default_Size"],
            "equipped": {"color": "Default", "shape": "Star", "size": 0}
        }

    # --- BLOCK 1: Helper Functions ---

    def test_01_clamp_normal(self):
        """
        @brief Tests the `clamp` function with values inside the range.
        @code
        val = clamp(5, 0, 10) # Expected: 5
        @endcode
        """
        self.assertEqual(reti.clamp(5, 0, 10), 5)

    def test_02_clamp_bounds(self):
        """
        @brief Tests the `clamp` function with values outside the range.
        @details Ensures values below min return min, and above max return max.
        """
        self.assertEqual(reti.clamp(-10, 0, 100), 0)
        self.assertEqual(reti.clamp(200, 0, 100), 100)

    # --- BLOCK 2: Localization ---

    def test_03_loc_default_en(self):
        """
        @brief Verifies the default language is English.
        """
        self.assertEqual(reti.loc.current_lang, "EN")

    def test_04_loc_translation_en(self):
        """
        @brief Verifies English key retrieval.
        """
        self.assertEqual(reti.loc.get("START"), "START")

    def test_05_loc_toggle_ua(self):
        """
        @brief Verifies language toggling to Ukrainian.
        @code
        loc.toggle_lang() # EN -> UA
        @endcode
        """
        reti.loc.toggle_lang()
        self.assertEqual(reti.loc.current_lang, "UA")
        self.assertEqual(reti.loc.get("START"), "ГРАТИ")

    def test_06_loc_toggle_back(self):
        """
        @brief Verifies language toggling back to English.
        """
        reti.loc.toggle_lang() # UA
        reti.loc.toggle_lang() # EN
        self.assertEqual(reti.loc.current_lang, "EN")

    def test_07_loc_missing_key(self):
        """
        @brief Verifies behavior when a translation key is missing.
        @details Should return the key itself.
        """
        self.assertEqual(reti.loc.get("NON_EXISTENT"), "NON_EXISTENT")

    # --- BLOCK 3: Theme Manager ---

    def test_08_theme_init(self):
        """
        @brief Verifies the initial theme is 'dark'.
        """
        self.assertEqual(reti.theme_mgr.current_theme, "dark")

    def test_09_theme_get_property(self):
        """
        @brief Verifies retrieval of theme properties (e.g., background color).
        """
        bg = reti.theme_mgr.get("bg_color")
        self.assertIsInstance(bg, tuple)

    def test_10_theme_transition_start(self):
        """
        @brief Tests the initialization of the theme transition state.
        @details Ensures `is_transitioning` becomes True and target is set.
        """
        reti.theme_mgr.start_transition()
        self.assertTrue(reti.theme_mgr.is_transitioning)
        self.assertEqual(reti.theme_mgr.target_theme, "light")

    def test_11_theme_update_no_transition(self):
        """
        @brief Verifies `update()` returns False when no transition is active.
        """
        reti.theme_mgr.is_transitioning = False
        self.assertFalse(reti.theme_mgr.update())

    def test_12_theme_colors_exist(self):
        """
        @brief Validates that shop colors are defined in the ThemeManager.
        """
        self.assertIn("Red", reti.theme_mgr.shop_colors)

    # --- BLOCK 4: Economy & Data ---

    def test_13_currency_init(self):
        """
        @brief Checks initial currency value from setUp.
        """
        self.assertEqual(self.game.get_currency(), 1000)

    def test_14_add_currency(self):
        """
        @brief Tests adding currency to the player's balance.
        """
        self.game.add_currency(500)
        self.assertEqual(self.game.get_currency(), 1500)

    def test_15_has_default_items(self):
        """
        @brief Verifies that default items are always owned.
        """
        self.assertTrue(self.game.has_item("color", "Default"))

    def test_16_buy_item_success(self):
        """
        @brief Tests a successful purchase transaction.
        @details Checks if function returns True and currency is deducted.
        """
        res = self.game.buy_item("color", "Blue", 100)
        self.assertTrue(res)
        self.assertEqual(self.game.get_currency(), 900)

    def test_17_buy_item_fail_funds(self):
        """
        @brief Tests a failed purchase due to insufficient funds.
        @details Checks if function returns False and currency remains unchanged.
        """
        self.game.data["currency"] = 10
        res = self.game.buy_item("color", "Gold", 1000)
        self.assertFalse(res)
        self.assertEqual(self.game.get_currency(), 10)

    def test_18_inventory_update_after_buy(self):
        """
        @brief Verifies item is added to inventory after purchase.
        """
        self.game.buy_item("color", "Green", 10)
        self.assertTrue(self.game.has_item("color", "Green"))

    def test_19_equip_item(self):
        """
        @brief Tests equipping an item.
        """
        self.game.equip_item("color", "Red")
        self.assertEqual(self.game.get_equipped("color"), "Red")

    def test_20_is_equipped_true(self):
        """
        @brief Verifies `is_equipped` returns True for equipped item.
        """
        self.game.equip_item("shape", "Triangle")
        self.assertTrue(self.game.is_equipped("shape", "Triangle"))

    def test_21_is_equipped_false(self):
        """
        @brief Verifies `is_equipped` returns False for non-equipped item.
        """
        self.assertFalse(self.game.is_equipped("shape", "Square"))

    def test_22_save_file_call(self):
        """
        @brief Mocks file I/O to verify `_save_data` attempts to write JSON.
        """
        with patch('json.dump') as mock_dump:
            with patch('builtins.open', unittest.mock.mock_open()):
                self.game._save_data()
                self.assertTrue(mock_dump.called)

    # --- BLOCK 5: High Score ---

    def test_23_highscore_init(self):
        """
        @brief Checks initial high score is 0.
        """
        self.assertEqual(self.game.get_high_score(), 0)

    def test_24_highscore_update_better(self):
        """
        @brief Tests updating high score when new score is higher.
        """
        self.game.update_high_score(500)
        self.assertEqual(self.game.get_high_score(), 500)

    def test_25_highscore_ignore_worse(self):
        """
        @brief Tests that high score is NOT updated when new score is lower.
        """
        self.game.update_high_score(500)
        self.game.update_high_score(100)
        self.assertEqual(self.game.get_high_score(), 500)

    # --- BLOCK 6: Game Objects - Basket ---

    def test_26_basket_init_pos(self):
        """
        @brief Calculates expected initial X position of the basket.
        @details Logic: (Screen Width - Basket Width) / 2.
        """
        basket = reti.Basket(self.game)
        # WIDTH=500, base_width=150 -> x = (500-150)/2 = 175
        self.assertEqual(basket._x, 175)

    def test_27_basket_width_calculation(self):
        """
        @brief Tests dynamic width calculation based on equipped 'size' item.
        """
        self.game.equip_item("size", 1) # +1 level
        basket = reti.Basket(self.game)
        width, _ = basket._get_current_properties()
        # 150 + 1*30 = 180
        self.assertEqual(width, 180)

    def test_28_basket_move_left(self):
        """
        @brief Tests left movement logic.
        @details Simulates 'Left Arrow' key press.
        """
        basket = reti.Basket(self.game)
        start_x = basket._x
        keys = {reti.pygame.K_LEFT: True, reti.pygame.K_RIGHT: False}
        basket.update(1.0, keys=keys)
        self.assertLess(basket._x, start_x)

    def test_29_basket_move_right(self):
        """
        @brief Tests right movement logic.
        """
        basket = reti.Basket(self.game)
        start_x = basket._x
        keys = {reti.pygame.K_LEFT: False, reti.pygame.K_RIGHT: True}
        basket.update(1.0, keys=keys)
        self.assertGreater(basket._x, start_x)

    def test_30_basket_boundary(self):
        """
        @brief Tests that basket stops at the screen boundary.
        """
        basket = reti.Basket(self.game)
        basket._x = 0
        keys = {reti.pygame.K_LEFT: True, reti.pygame.K_RIGHT: False}
        basket.update(1.0, keys=keys)
        # Should stay at 0 or be clamped logic handles it
        self.assertEqual(basket._x, 0) 

    # --- BLOCK 7: Game Objects - Star/Currency ---

    def test_31_star_fall(self):
        """
        @brief Verifies that stars move downwards (increase Y value).
        """
        star = reti.Star(1.0, self.game)
        start_y = star.get_y()
        star.update(1.0)
        self.assertGreater(star.get_y(), start_y)

    def test_32_star_points(self):
        """
        @brief Verifies star points are within expected range based on size.
        """
        star = reti.Star(1.0, self.game)
        self.assertTrue(5 <= star.get_points() <= 15)

    def test_33_star_rhythm_mode(self):
        """
        @brief Tests specific attributes for Rhythm Mode stars.
        @details Must have `_is_rhythm_note` flag set.
        """
        star = reti.Star(1.0, self.game, fixed_x=100, note_name="C")
        self.assertTrue(star._is_rhythm_note)
        self.assertEqual(star.get_note_name(), "C")

    def test_34_currency_fall(self):
        """
        @brief Verifies currency objects fall downwards.
        """
        curr = reti.Currency(1.0)
        start_y = curr.get_y()
        curr.update(1.0)
        self.assertGreater(curr.get_y(), start_y)

    def test_35_particle_lifetime(self):
        """
        @brief Tests particle expiration.
        @details Particle should return False on update when lifetime exceeds dt.
        """
        p = reti.Particle(0, 0)
        p._lifetime = 0.1
        alive = p.update(0.2) # dt > lifetime
        self.assertFalse(alive)

    def test_36_particle_init(self):
        """
        @brief Simple particle initialization test.
        """
        p = reti.Particle(10, 20)
        self.assertEqual(p._x, 10)

    # --- BLOCK 8: Object Manager ---

    def test_37_manager_add(self):
        """
        @brief Tests adding an object to ObjectManager.
        """
        mgr = reti.ObjectManager()
        obj = reti.Particle(0,0)
        mgr.add(obj)
        self.assertEqual(len(mgr.get_list()), 1)

    def test_38_manager_remove(self):
        """
        @brief Tests removing an object from ObjectManager.
        """
        mgr = reti.ObjectManager()
        obj = reti.Particle(0,0)
        mgr.add(obj)
        mgr.remove(obj)
        self.assertEqual(len(mgr.get_list()), 0)

    def test_39_manager_clear(self):
        """
        @brief Tests clearing all objects from ObjectManager.
        """
        mgr = reti.ObjectManager()
        mgr.add(reti.Particle(0,0))
        mgr.add(reti.Particle(1,1))
        mgr.clear()
        self.assertEqual(len(mgr.get_list()), 0)

    def test_40_manager_update_all(self):
        """
        @brief Verifies `update_all` calls update on all contained objects.
        """
        mgr = reti.ObjectManager()
        # Mock object
        m_obj = MagicMock()
        mgr.add(m_obj)
        mgr.update_all(0.1)
        m_obj.update.assert_called_with(0.1)

    # --- BLOCK 9: UI Elements ---

    def test_41_button_init(self):
        """
        @brief Tests Button initialization key storage.
        """
        font = MagicMock()
        btn = reti.Button(0, 0, 100, 50, "TEST", "normal", font)
        self.assertEqual(btn._text_key, "TEST")

    def test_42_button_hover(self):
        """
        @brief Tests Button hover detection logic.
        @details Mocks `rect.collidepoint`.
        """
        mock_rect = MagicMock()
        mock_rect.collidepoint.return_value = True
        
        btn = reti.Button(0, 0, 100, 50, "T", "n", MagicMock())
        btn._rect = mock_rect
        
        btn.update(0.1, mouse_pos=(10, 10))
        self.assertTrue(btn._is_hovered)

    def test_43_slider_init(self):
        """
        @brief Tests Slider initial value.
        """
        slider = reti.Slider(0,0,100,10, 0.0, 1.0, 0.5, MagicMock())
        self.assertEqual(slider.get_value(), 0.5)

    def test_44_slider_logic_min(self):
        """
        @brief Tests Slider logic when dragged to minimum position (left).
        """
        slider = reti.Slider(0,0,100,10, 0.0, 1.0, 0.5, MagicMock())
        slider._rect = MagicMock()
        slider._rect.x = 0; slider._rect.w = 100
        slider._update_val_from_pos(0)
        self.assertEqual(slider.get_value(), 0.0)

    def test_45_slider_logic_max(self):
        """
        @brief Tests Slider logic when dragged to maximum position (right).
        """
        slider = reti.Slider(0,0,100,10, 0.0, 1.0, 0.5, MagicMock())
        slider._rect = MagicMock()
        slider._rect.x = 0; slider._rect.w = 100
        slider._update_val_from_pos(100)
        self.assertEqual(slider.get_value(), 1.0)

    # --- BLOCK 10: Logic Integration ---

    def test_46_settings_volume(self):
        """
        @brief Tests integration between Settings State and Pygame Mixer volume.
        """
        with patch('pygame.mixer.music.set_volume') as m_vol:
            state = reti.SettingsState(self.game)
            # Fake event for slider drag simulation
            state._slider_music._current_val = 0.8
            # Manually trigger the update logic logic
            reti.pygame.mixer.music.set_volume(0.8) 
            m_vol.assert_called_with(0.8)

    def test_47_shop_tab_switch(self):
        """
        @brief Tests Shop State tab switching logic (Colors -> Sizes).
        """
        state = reti.ShopState(self.game)
        self.assertEqual(state._current_tab, "Colors")
        # Trigger change manually
        state._current_tab = "Sizes"
        state._create_item_buttons()
        # Check if first item is Size related (val=1 for Large)
        self.assertEqual(state._items[0]._category, "size")

    def test_48_playing_state_reset(self):
        """
        @brief Tests `reset_game` logic in PlayingState.
        @details Ensures score and counters are reset to zero.
        """
        state = reti.PlayingState(self.game)
        state._score = 100
        state.reset_game()
        self.assertEqual(state._score, 0)

    def test_49_song_list_integrity(self):
        """
        @brief Verifies the global `SONG_LIST` is not empty and has correct keys.
        """
        self.assertGreater(len(reti.SONG_LIST), 0)
        self.assertIn("bpm", reti.SONG_LIST[0])

    def test_50_measure_time_decorator(self):
        """
        @brief Tests the microbenchmarking decorator.
        @details Checks if the function executes and logs output.
        """
        @reti.measure_time
        def dummy():
            return "ok"
        
        with self.assertLogs(level='INFO') as log:
            res = dummy()
            self.assertEqual(res, "ok")
            self.assertTrue(any("Performance: dummy took" in m for m in log.output))

    # --- BLOCK 11: End-to-End & Complex Scenarios (NEW TESTS) ---

    def test_51_state_transition_integration(self):
        """
        @brief E2E Test: Verifies changing state from Menu to Playing.
        @details Checks if `change_state` updates `_current_state` instance correctly.
        """
        menu_state = reti.MenuState(self.game)
        self.game._current_state = menu_state
        
        # Simulate Start Button action
        new_state = reti.PlayingState(self.game)
        self.game.change_state(new_state)
        
        self.assertIsInstance(self.game._current_state, reti.PlayingState)

    def test_52_rhythm_spawn_logic(self):
        """
        @brief Logic Test: Verifies Rhythm notes spawn based on timer.
        @details Simulates time passing and checks if StarManager increases count.
        """
        song_data = {"name": "Test", "bpm": 60, "note_id": "1"}
        state = reti.RhythmGameState(self.game, song_data)
        
        # Initial state: 0 stars
        self.assertEqual(len(state._star_manager.get_list()), 0)
        
        # Force timer to exceed beat time
        state._next_beat_time = 0.5
        state.update(1.0) # dt = 1.0s
        
        # Should spawn at least one star
        self.assertGreater(len(state._star_manager.get_list()), 0)

    def test_53_collision_scoring_simulation(self):
        """
        @brief Physics/Score Test: Simulates a collision between Basket and Star.
        @details Manually places a star at basket coordinates and calls update.
        """
        state = reti.PlayingState(self.game)
        
        # Place star exactly where basket is
        basket_x = state._basket._x
        basket_y = state._basket._y
        
        # Create a Star and force its rect to overlap basket
        star = reti.Star(1.0, self.game)
        # Mocking rects to ensure collision
        star.get_rect = MagicMock(return_value=mock_pygame.Rect(basket_x, basket_y, 10, 10))
        state._basket.get_rect = MagicMock(return_value=mock_pygame.Rect(basket_x, basket_y, 50, 50))
        
        state._star_manager.add(star)
        
        # Run collision logic
        state._handle_collisions()
        
        # Score should increase (base star points is ~5-15)
        self.assertGreater(state._score, 0)
        # Star should be removed
        self.assertEqual(len(state._star_manager.get_list()), 0)

    def test_54_game_over_trigger(self):
        """
        @brief Logic Test: Verifies Game Over state triggers after max misses.
        """
        state = reti.PlayingState(self.game)
        
        # Force max missed stars
        state._missed_stars = reti.MAX_MISSED_STARS
        
        # Add a star that is "off screen" (y > HEIGHT)
        star = reti.Star(1.0, self.game)
        star.get_y = MagicMock(return_value=reti.HEIGHT + 100)
        state._star_manager.add(star)
        
        # Run collision logic (which handles misses)
        state._handle_collisions()
        
        # Should transition to GameOverState
        self.assertIsInstance(self.game._current_state, reti.GameOverState)

    def test_55_pause_toggle(self):
        """
        @brief Logic Test: Verifies PausedState wraps the previous state.
        """
        playing_state = reti.PlayingState(self.game)
        self.game._current_state = playing_state
        
        # Trigger pause
        pause_state = reti.PausedState(self.game, playing_state)
        self.game.change_state(pause_state)
        
        self.assertIsInstance(self.game._current_state, reti.PausedState)
        self.assertEqual(self.game._current_state._previous_state, playing_state)

if __name__ == "__main__":
    # Run tests
    unittest.main()