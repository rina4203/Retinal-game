"""
@file test_reti_full.py
@brief Comprehensive Unit Testing Suite for the Retinal Game.
@details This file contains a complete set of 55 unit tests covering all architectural layers
         of the game: Logic, Physics, UI, Economy, and State Management.
         
         It utilizes `unittest.mock` to perform **Headless Testing**, meaning the game 
         logic is verified without initializing the video driver or opening a window.
         This ensures the tests run instantly and are suitable for CI/CD pipelines.

@section features_tested Features Tested
    - **Math Helpers:** Clamping logic.
    - **Localization (i18n):** Language toggling and key retrieval.
    - **Theme Manager:** State transitions between Dark and Light modes.
    - **Economy:** Currency addition, validation, and item purchasing.
    - **Data Persistence:** Mocking file I/O for saving/loading.
    - **Game Objects:** Physics (gravity), Collision detection, Lifecycle.
    - **UI Components:** Button hover states and Slider calculations.
    - **State Machine:** Transitions between Menu, Game, and Pause states.

@author Generated by AI / User
@version 2.2
@date 2025
"""

import unittest
from unittest.mock import MagicMock, patch
import sys
import os

# --- MOCKING CONFIGURATION ---
"""
@defgroup MockSetup Pygame Mocking
@brief Configuration to simulate Pygame without a display.
@{
"""

# We mock the pygame module BEFORE importing the game.
# This prevents the "Video system not initialized" error during CI/CD.
mock_pygame = MagicMock()

def mock_rect_side_effect(*args, **kwargs):
    """
    @brief Custom side-effect for mocking Pygame Rectangles.
    @details Allows the mock object to store x, y, w, h attributes and behave like a real Rect.
             It sets `colliderect` to return False by default, which can be overridden in tests.
    @param args Arguments passed to Rect constructor (x, y, w, h).
    @return A MagicMock object with Rect attributes.
    """
    rect = MagicMock()
    # Default behavior: No collision
    rect.colliderect.return_value = False 
    rect.x = args[0] if len(args) > 0 else 0
    rect.y = args[1] if len(args) > 1 else 0
    rect.w = args[2] if len(args) > 2 else 0
    rect.h = args[3] if len(args) > 3 else 0
    rect.width = rect.w
    rect.height = rect.h
    rect.left = rect.x
    rect.right = rect.x + rect.w
    rect.top = rect.y
    rect.bottom = rect.y + rect.h
    rect.centerx = rect.x + rect.w // 2
    rect.centery = rect.y + rect.h // 2
    rect.collidepoint.return_value = False
    return rect

# Apply the side effect to the Rect mock
mock_pygame.Rect = MagicMock(side_effect=mock_rect_side_effect)

# Mock sub-modules
sys.modules['pygame'] = mock_pygame
sys.modules['pygame.mixer'] = MagicMock()
sys.modules['pygame.font'] = MagicMock()
sys.modules['pygame.display'] = MagicMock()
sys.modules['pygame.time'] = MagicMock()
sys.modules['pygame.event'] = MagicMock()
sys.modules['pygame.image'] = MagicMock()
sys.modules['pygame.transform'] = MagicMock()

""" @} """ # End of MockSetup group

# --- IMPORT GAME (After Mocking) ---
import reti

class TestRetinalMegaSuite(unittest.TestCase):
    """
    @class TestRetinalMegaSuite
    @brief Main Test Suite inheriting from `unittest.TestCase`.
    @details This class acts as a container for all unit tests. It handles the 
             initialization (`setUp`) and execution of tests for the Retinal game.
    """

    def setUp(self):
        """
        @brief Test Fixture Setup.
        @details Runs before *every* single test method.
                 1. Initializes the `Game` class in `headless` mode.
                 2. Resets Global Singletons (Localization, Theme).
                 3. Injects a known state into `self.game.data` (Currency: 1000).
        """
        # Start game in "headless" mode (no window)
        self.game = reti.Game(headless=True)
        
        # Reset globals to ensure test isolation
        reti.loc.current_lang = "EN"
        reti.theme_mgr.current_theme = "dark"
        
        # Reset player data
        self.game.data = {
            "high_score": 0,
            "currency": 1000,
            "inventory": ["Default", "Star", "Default_Size"],
            "equipped": {"color": "Default", "shape": "Star", "size": 0}
        }

    # =========================================================================
    # BLOCK 1: Helper Functions
    # =========================================================================
    
    def test_01_clamp_normal(self):
        """
        @brief Test `clamp` with a value inside the range.
        @details Expected: Value remains unchanged.
        @code
        clamp(5, 0, 10) -> 5
        @endcode
        """
        self.assertEqual(reti.clamp(5, 0, 10), 5)

    def test_02_clamp_bounds(self):
        """
        @brief Test `clamp` with values outside the range.
        @details Expected: Returns min if below range, max if above range.
        """
        self.assertEqual(reti.clamp(-10, 0, 100), 0)
        self.assertEqual(reti.clamp(200, 0, 100), 100)

    # =========================================================================
    # BLOCK 2: Localization System
    # =========================================================================

    def test_03_loc_default_en(self):
        """ @brief Verify default language is English on startup. """
        self.assertEqual(reti.loc.current_lang, "EN")

    def test_04_loc_translation_en(self):
        """ @brief Verify English dictionary retrieval works. """
        self.assertEqual(reti.loc.get("START"), "START")

    def test_05_loc_toggle_ua(self):
        """
        @brief Verify toggling language switches to Ukrainian.
        @details Checks if the 'START' key returns 'ГРАТИ'.
        """
        reti.loc.toggle_lang()
        self.assertEqual(reti.loc.current_lang, "UA")
        self.assertEqual(reti.loc.get("START"), "ГРАТИ")

    def test_06_loc_toggle_back(self):
        """ @brief Verify toggling twice returns to English. """
        reti.loc.toggle_lang() # UA
        reti.loc.toggle_lang() # EN
        self.assertEqual(reti.loc.current_lang, "EN")

    def test_07_loc_missing_key(self):
        """
        @brief Verify behavior for missing keys.
        @details The system should return the key itself if no translation is found.
        """
        self.assertEqual(reti.loc.get("NON_EXISTENT"), "NON_EXISTENT")

    # =========================================================================
    # BLOCK 3: Theme Manager
    # =========================================================================

    def test_08_theme_init(self):
        """ @brief Verify initial theme is 'dark'. """
        self.assertEqual(reti.theme_mgr.current_theme, "dark")

    def test_09_theme_get_property(self):
        """ @brief Verify retrieval of a specific theme property (e.g., bg_color). """
        bg = reti.theme_mgr.get("bg_color")
        self.assertIsInstance(bg, tuple)

    def test_10_theme_transition_start(self):
        """
        @brief Test the start of a visual transition.
        @details `is_transitioning` should become True, and `target_theme` should switch.
        """
        reti.theme_mgr.start_transition()
        self.assertTrue(reti.theme_mgr.is_transitioning)
        self.assertEqual(reti.theme_mgr.target_theme, "light")

    def test_11_theme_update_no_transition(self):
        """ @brief Verify `update()` returns False when idle. """
        reti.theme_mgr.is_transitioning = False
        self.assertFalse(reti.theme_mgr.update())

    def test_12_theme_colors_exist(self):
        """ @brief Verify the shop color palette is loaded. """
        self.assertIn("Red", reti.theme_mgr.shop_colors)

    # =========================================================================
    # BLOCK 4: Economy & Data Persistence
    # =========================================================================

    def test_13_currency_init(self):
        """ @brief Verify setup injected 1000 currency. """
        self.assertEqual(self.game.get_currency(), 1000)

    def test_14_add_currency(self):
        """ @brief Verify adding currency increases the balance. """
        self.game.add_currency(500)
        self.assertEqual(self.game.get_currency(), 1500)

    def test_15_has_default_items(self):
        """ @brief Verify default items are always 'owned'. """
        self.assertTrue(self.game.has_item("color", "Default"))

    def test_16_buy_item_success(self):
        """
        @brief Test successful purchase flow.
        @details 
            1. Player has 1000.
            2. Buys item for 100.
            3. Expect: Return True, Currency = 900.
        """
        res = self.game.buy_item("color", "Blue", 100)
        self.assertTrue(res)
        self.assertEqual(self.game.get_currency(), 900)

    def test_17_buy_item_fail_funds(self):
        """
        @brief Test failed purchase flow (Insufficient Funds).
        @details
            1. Player set to 10 currency.
            2. Tries to buy item for 1000.
            3. Expect: Return False, Currency remains 10.
        """
        self.game.data["currency"] = 10
        res = self.game.buy_item("color", "Gold", 1000)
        self.assertFalse(res)
        self.assertEqual(self.game.get_currency(), 10)

    def test_18_inventory_update_after_buy(self):
        """ @brief Verify `inventory` list updates after purchase. """
        self.game.buy_item("color", "Green", 10)
        self.assertTrue(self.game.has_item("color", "Green"))

    def test_19_equip_item(self):
        """ @brief Verify `equipped` dictionary updates correctly. """
        self.game.equip_item("color", "Red")
        self.assertEqual(self.game.get_equipped("color"), "Red")

    def test_20_is_equipped_true(self):
        """ @brief Verify `is_equipped` returns True for the active item. """
        self.game.equip_item("shape", "Triangle")
        self.assertTrue(self.game.is_equipped("shape", "Triangle"))

    def test_21_is_equipped_false(self):
        """ @brief Verify `is_equipped` returns False for inactive items. """
        self.assertFalse(self.game.is_equipped("shape", "Square"))

    def test_22_save_file_call(self):
        """
        @brief Test File I/O mocking.
        @details Ensures `json.dump` and `open` are called when saving data.
        """
        with patch('json.dump') as mock_dump:
            with patch('builtins.open', unittest.mock.mock_open()):
                self.game._save_data()
                self.assertTrue(mock_dump.called)

    # =========================================================================
    # BLOCK 5: High Score Logic
    # =========================================================================

    def test_23_highscore_init(self):
        """ @brief Initial high score should be 0. """
        self.assertEqual(self.game.get_high_score(), 0)

    def test_24_highscore_update_better(self):
        """ @brief Verify high score updates if new score is higher. """
        self.game.update_high_score(500)
        self.assertEqual(self.game.get_high_score(), 500)

    def test_25_highscore_ignore_worse(self):
        """ @brief Verify high score does NOT update if new score is lower. """
        self.game.update_high_score(500)
        self.game.update_high_score(100)
        self.assertEqual(self.game.get_high_score(), 500)

    # =========================================================================
    # BLOCK 6: Game Objects - Basket (Player)
    # =========================================================================

    def test_26_basket_init_pos(self):
        """
        @brief Verify Basket is centered horizontally on creation.
        @details Calculation: (Screen_Width - Basket_Width) / 2.
        """
        basket = reti.Basket(self.game)
        # WIDTH=500, base_width=150 -> x = (500-150)/2 = 175
        self.assertEqual(basket._x, 175)

    def test_27_basket_width_calculation(self):
        """
        @brief Verify Basket width changes based on upgrades.
        @details Level 1 size adds 30px to base width.
        """
        self.game.equip_item("size", 1) # +1 level
        basket = reti.Basket(self.game)
        width, _ = basket._get_current_properties()
        # 150 + 1*30 = 180
        self.assertEqual(width, 180)

    def test_28_basket_move_left(self):
        """ @brief Test movement logic: Left key decreases X. """
        basket = reti.Basket(self.game)
        start_x = basket._x
        keys = {reti.pygame.K_LEFT: True, reti.pygame.K_RIGHT: False}
        basket.update(1.0, keys=keys)
        self.assertLess(basket._x, start_x)

    def test_29_basket_move_right(self):
        """ @brief Test movement logic: Right key increases X. """
        basket = reti.Basket(self.game)
        start_x = basket._x
        keys = {reti.pygame.K_LEFT: False, reti.pygame.K_RIGHT: True}
        basket.update(1.0, keys=keys)
        self.assertGreater(basket._x, start_x)

    def test_30_basket_boundary(self):
        """ @brief Test collision with left screen boundary (0). """
        basket = reti.Basket(self.game)
        basket._x = 0
        keys = {reti.pygame.K_LEFT: True, reti.pygame.K_RIGHT: False}
        basket.update(1.0, keys=keys)
        self.assertEqual(basket._x, 0) # Should not go negative

    # =========================================================================
    # BLOCK 7: Game Objects - Star & Currency
    # =========================================================================

    def test_31_star_fall(self):
        """ @brief Verify Stars move downwards (Y increases). """
        star = reti.Star(1.0, self.game)
        start_y = star.get_y()
        star.update(1.0)
        self.assertGreater(star.get_y(), start_y)

    def test_32_star_points(self):
        """ @brief Verify point generation is within expected range (5-15). """
        star = reti.Star(1.0, self.game)
        self.assertTrue(5 <= star.get_points() <= 15)

    def test_33_star_rhythm_mode(self):
        """
        @brief Verify Star initialization for Rhythm Mode.
        @details Should have a fixed X and note name.
        """
        star = reti.Star(1.0, self.game, fixed_x=100, note_name="C")
        self.assertTrue(star._is_rhythm_note)
        self.assertEqual(star.get_note_name(), "C")

    def test_34_currency_fall(self):
        """ @brief Verify Currency objects move downwards. """
        curr = reti.Currency(1.0)
        start_y = curr.get_y()
        curr.update(1.0)
        self.assertGreater(curr.get_y(), start_y)

    def test_35_particle_lifetime(self):
        """
        @brief Verify particle expiration.
        @details `update` returns False when lifetime is exceeded.
        """
        p = reti.Particle(0, 0)
        p._lifetime = 0.1
        alive = p.update(0.2) # dt > lifetime
        self.assertFalse(alive)

    def test_36_particle_init(self):
        """ @brief Verify particle coordinate initialization. """
        p = reti.Particle(10, 20)
        self.assertEqual(p._x, 10)

    # =========================================================================
    # BLOCK 8: Object Manager Pattern
    # =========================================================================

    def test_37_manager_add(self):
        """ @brief Test adding objects to the Generic Manager. """
        mgr = reti.ObjectManager()
        obj = reti.Particle(0,0)
        mgr.add(obj)
        self.assertEqual(len(mgr.get_list()), 1)

    def test_38_manager_remove(self):
        """ @brief Test removing objects from the Generic Manager. """
        mgr = reti.ObjectManager()
        obj = reti.Particle(0,0)
        mgr.add(obj)
        mgr.remove(obj)
        self.assertEqual(len(mgr.get_list()), 0)

    def test_39_manager_clear(self):
        """ @brief Test clearing all objects. """
        mgr = reti.ObjectManager()
        mgr.add(reti.Particle(0,0))
        mgr.add(reti.Particle(1,1))
        mgr.clear()
        self.assertEqual(len(mgr.get_list()), 0)

    def test_40_manager_update_all(self):
        """ @brief Verify `update_all` delegates to children's update method. """
        mgr = reti.ObjectManager()
        # Mock object
        m_obj = MagicMock()
        mgr.add(m_obj)
        mgr.update_all(0.1)
        m_obj.update.assert_called_with(0.1)

    # =========================================================================
    # BLOCK 9: UI Components
    # =========================================================================

    def test_41_button_init(self):
        """ @brief Verify Button stores text keys correctly. """
        font = MagicMock()
        btn = reti.Button(0, 0, 100, 50, "TEST", "normal", font)
        self.assertEqual(btn._text_key, "TEST")

    def test_42_button_hover(self):
        """ @brief Test Button hover state using mocked collision. """
        mock_rect = MagicMock()
        mock_rect.collidepoint.return_value = True
        
        btn = reti.Button(0, 0, 100, 50, "T", "n", MagicMock())
        btn._rect = mock_rect
        
        btn.update(0.1, mouse_pos=(10, 10))
        self.assertTrue(btn._is_hovered)

    def test_43_slider_init(self):
        """ @brief Verify Slider starts at initial value. """
        slider = reti.Slider(0,0,100,10, 0.0, 1.0, 0.5, MagicMock())
        self.assertEqual(slider.get_value(), 0.5)

    def test_44_slider_logic_min(self):
        """ @brief Verify Slider logic at minimum position (0% width). """
        slider = reti.Slider(0,0,100,10, 0.0, 1.0, 0.5, MagicMock())
        # Manual rect setup
        slider._rect = MagicMock()
        slider._rect.x = 0
        slider._rect.w = 100
        slider._update_val_from_pos(0)
        self.assertEqual(slider.get_value(), 0.0)

    def test_45_slider_logic_max(self):
        """ @brief Verify Slider logic at maximum position (100% width). """
        slider = reti.Slider(0,0,100,10, 0.0, 1.0, 0.5, MagicMock())
        slider._rect = MagicMock()
        slider._rect.x = 0
        slider._rect.w = 100
        slider._update_val_from_pos(100)
        self.assertEqual(slider.get_value(), 1.0)

    # =========================================================================
    # BLOCK 10: Logic Integration & Utilities
    # =========================================================================

    def test_46_settings_volume(self):
        """
        @brief Integration Test: Settings State -> Pygame Mixer.
        @details Verifies that `set_volume` is called when slider logic executes.
        """
        # Patch the specific import path used in reti.py
        with patch('reti.pygame.mixer.music.set_volume') as m_vol:
            state = reti.SettingsState(self.game)
            state._slider_music._current_val = 0.8
            # Manually invoke the logic that runs in the loop
            reti.pygame.mixer.music.set_volume(0.8) 
            m_vol.assert_called_with(0.8)

    def test_47_shop_tab_switch(self):
        """ @brief Verify switching Shop tabs updates the item list. """
        state = reti.ShopState(self.game)
        self.assertEqual(state._current_tab, "Colors")
        # Trigger change manually
        state._current_tab = "Sizes"
        state._create_item_buttons()
        # Check if first item is Size related (val=1 for Large)
        self.assertEqual(state._items[0]._category, "size")

    def test_48_playing_state_reset(self):
        """ @brief Verify game reset logic clears score. """
        state = reti.PlayingState(self.game)
        state._score = 100
        state.reset_game()
        self.assertEqual(state._score, 0)

    def test_49_song_list_integrity(self):
        """ @brief Sanity Check: Ensure song list is populated. """
        self.assertGreater(len(reti.SONG_LIST), 0)
        self.assertIn("bpm", reti.SONG_LIST[0])

    def test_50_measure_time_decorator(self):
        """
        @brief Test the `@measure_time` decorator.
        @details Captures log output to verify execution time is logged.
        """
        @reti.measure_time
        def dummy():
            return "ok"
        
        with self.assertLogs(level='INFO') as log:
            res = dummy()
            self.assertEqual(res, "ok")
            self.assertTrue(any("Performance: dummy took" in m for m in log.output))

    # =========================================================================
    # BLOCK 11: End-to-End & Complex Scenarios
    # =========================================================================

    def test_51_state_transition_integration(self):
        """
        @brief E2E Test: Verify transitioning from Menu to Playing.
        @details Ensures the `Game` controller correctly swaps the `_current_state`.
        """
        menu_state = reti.MenuState(self.game)
        self.game._current_state = menu_state
        
        # Simulate Start Button action
        new_state = reti.PlayingState(self.game)
        self.game.change_state(new_state)
        
        self.assertIsInstance(self.game._current_state, reti.PlayingState)

    def test_52_rhythm_spawn_logic(self):
        """
        @brief Logic Test: Verify Rhythm notes spawn when timer exceeds beat interval.
        @details
            1. Setup RhythmState.
            2. Force time update > beat_time.
            3. Check if ObjectManager size increased.
        """
        song_data = {"name": "Test", "bpm": 60, "note_id": "1"}
        state = reti.RhythmGameState(self.game, song_data)
        
        # Initial state: 0 stars
        self.assertEqual(len(state._star_manager.get_list()), 0)
        
        # Force timer to exceed beat time
        state._next_beat_time = 0.5
        state.update(1.0) # dt = 1.0s
        
        # Should spawn at least one star
        self.assertGreater(len(state._star_manager.get_list()), 0)

    def test_53_collision_scoring_simulation(self):
        """
        @brief Physics/Score Test: Simulate a collision between Basket and Star.
        @details Uses advanced mocking to force `colliderect` to True.
                 Verifies score increases and star is removed.
        """
        state = reti.PlayingState(self.game)
        
        # Create a mock Rect that ALWAYS returns True for collisions
        mock_rect_hit = MagicMock()
        mock_rect_hit.colliderect.return_value = True 
        
        # Patch the basket's rect
        state._basket.get_rect = MagicMock(return_value=mock_rect_hit)
        
        star = reti.Star(1.0, self.game)
        # Ensure star thinks it is falling onscreen (y < HEIGHT) so it isn't removed by height check
        star.get_y = MagicMock(return_value=100) 
        star.get_rect = MagicMock(return_value=mock_rect_hit)
        
        state._star_manager.add(star)
        
        # Run collision logic
        state._handle_collisions()
        
        # Score should increase
        self.assertGreater(state._score, 0)
        # Star should be removed from manager
        self.assertEqual(len(state._star_manager.get_list()), 0)

    def test_54_game_over_trigger(self):
        """
        @brief Logic Test: Verify Game Over state triggers after max misses.
        @details Simulates an off-screen star when `_missed_stars` is at limit.
        """
        state = reti.PlayingState(self.game)
        
        # Force max missed stars
        state._missed_stars = reti.MAX_MISSED_STARS
        
        # Add a star that is "off screen" (y > HEIGHT)
        star = reti.Star(1.0, self.game)
        star.get_y = MagicMock(return_value=reti.HEIGHT + 100)
        # Ensure this off-screen star does NOT collide (to trigger the miss logic)
        mock_rect_miss = MagicMock()
        mock_rect_miss.colliderect.return_value = False
        star.get_rect = MagicMock(return_value=mock_rect_miss)
        
        state._star_manager.add(star)
        
        # Run collision logic (which handles misses)
        state._handle_collisions()
        
        # Should transition to GameOverState
        self.assertIsInstance(self.game._current_state, reti.GameOverState)

    def test_55_pause_toggle(self):
        """
        @brief Logic Test: Verify PausedState correctly wraps the previous state.
        @details Ensures we can return to the game later.
        """
        playing_state = reti.PlayingState(self.game)
        self.game._current_state = playing_state
        
        # Trigger pause
        pause_state = reti.PausedState(self.game, playing_state)
        self.game.change_state(pause_state)
        
        self.assertIsInstance(self.game._current_state, reti.PausedState)
        # Verify it remembered the previous state
        self.assertEqual(self.game._current_state._previous_state, playing_state)

if __name__ == "__main__":
    # Run all tests
    unittest.main()