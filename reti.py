"""
@file reti.py
@brief Main entry point for the "Retinal" rhythm game.
@details This file contains the main game loop, state management, and game objects.
         It implements the State pattern for game screens, Singleton pattern for managers, and Factory pattern for object creation.
         Key features include Internationalization (i18n), Logging, and Theme switching.
@author Generated by AI / User
@version 1.6
@date 2025
"""

import os
import sys
# Disable Pygame support prompt
os.environ['PYGAME_HIDE_SUPPORT_PROMPT'] = "hide"

import pygame
import random
import math
import json
import logging
import time
import functools
import unittest
from abc import ABC, abstractmethod
from typing import List, TypeVar, Generic, Optional, Dict, Any

# --- LOGGING SETUP ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("game_log.log"),
        logging.StreamHandler()
    ]
)

# --- FILE PATHS ---
SOUND_FOLDER = "sound"           #< Directory containing audio files
FONT_FOLDER = "etc"              #< Directory containing font files (НОВА ЗМІННА)

HIGHSCORE_FILE = "highscore.txt" #< File to store local high scores
SAVE_FILE = "save_data.json"     #< JSON file for persistence (currency, inventory)
NOTES_FILE = "notes.json"        #< JSON file containing beatmaps

# Font files configuration (ОНОВЛЕНО ШЛЯХИ)
FONT_FILE_EN = os.path.join(FONT_FOLDER, "font.otf")               #< Custom font for English
FONT_FILE_UA = os.path.join(FONT_FOLDER, "FiorinaTitle-Light.otf") #< Custom font for Ukrainian

# --- SONG CONFIGURATION ---
"""
@var SONG_LIST
@brief List of available songs for the Rhythm Game mode.
"""
SONG_LIST = [
    { "name": "Twinkle Twinkle",     "bpm": 100, "note_id": "1" },
    { "name": "Happy Birthday",      "bpm": 110, "note_id": "2" },
    { "name": "Birds of a Feather",  "bpm": 120, "note_id": "3" },
    { "name": "Rolling in the Deep", "bpm": 125, "note_id": "4" }
]

# --- MICROBENCHMARKING UTILS ---
def measure_time(func):
    """
    @brief Decorator to measure and log the execution time of a function.
    @details Used for microbenchmarking critical sections of the code.
    
    @param func The function to be decorated.
    @return The wrapped function result.
    """
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.perf_counter()
        result = func(*args, **kwargs)
        end_time = time.perf_counter()
        execution_time = (end_time - start_time) * 1000  # ms
        logging.info(f"Performance: {func.__name__} took {execution_time:.4f} ms")
        return result
    return wrapper

# --- PYGAME INIT ---
# Initialize only if not testing or explicitly needed, but standard init is safe here
pygame.init()
pygame.mixer.set_num_channels(64) 

# --- CONSTANTS ---
WIDTH, HEIGHT = 500, 800
FPS = 60
MAX_PLATFORM_SPEED = 14
NUM_BG_STARS = 200
MAX_MISSED_STARS = 10
LANE_WIDTH = WIDTH // 3
LANE_CENTERS = [LANE_WIDTH * 0.5, LANE_WIDTH * 1.5, LANE_WIDTH * 2.5]

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED_ERROR = (215, 80, 80)
GOLD = (240, 200, 80)
GREEN_BUY = (100, 200, 120)
PASTEL_CREAM = (255, 253, 208)
BOHO_BG = (135, 206, 250)

SHOP_COLORS = {
    "Default": None, "Red": (230, 100, 100), "Orange": (240, 160, 100),
    "Yellow": (240, 220, 100), "Green": (120, 180, 120), "Cyan": (100, 200, 200),
    "Blue": (100, 140, 200), "Purple": (160, 120, 200), "Pink": (230, 150, 180)
}

# --- I18N SYSTEM ---

class LocalizationManager:
    """
    @brief Manages localization and string translation.
    @details Holds dictionaries for supported languages (EN, UA) and provides methods to retrieve localized strings.
    @class LocalizationManager
    """
    def __init__(self):
        """
        @brief Initializes the LocalizationManager with default language (EN).
        """
        self.current_lang = "EN"
        self.translations = {
            "EN": {
                # Main Menu
                "START": "START", "RHYTHM": "RHYTHM", "SHOP": "SHOP", "SETTINGS": "SETTINGS", "QUIT": "QUIT",
                "LANG": "LANGUAGE: EN", "LIGHT": "LIGHT", "DARK": "DARK",
                
                # General
                "BACK": "BACK", "RESET": "RESET", "GAME_OVER": "GAME OVER", 
                "SCORE": "Score:", "HIGH_SCORE": "High Score:", 
                "RETRY": "RETRY", "MENU": "MENU", "PAUSED": "PAUSED",
                "RESUME": "RESUME", "NO_MUSIC": "NO MUSIC FILE", "ARE_YOU_SURE": "Are you sure?",
                "YES": "YES", "NO": "NO",
                
                # Settings
                "AUDIO": "AUDIO", "DIFFICULTY": "DIFFICULTY",
                "MUSIC_VOL": "Music:", "SFX_VOL": "SFX:",
                "EASY": "Easy", "NORMAL": "Normal", "HARD": "Hard",
                
                # Shop
                "TAB_COLORS": "Colors", "TAB_SIZES": "Sizes", "TAB_SHAPES": "Shapes",
                "CURRENCY": "Cash:", "OWNED": "OWNED", "EQUIPPED": "EQUIPPED",
                
                # Items (Colors)
                "Red": "Red", "Orange": "Orange", "Yellow": "Yellow", "Green": "Green", 
                "Cyan": "Cyan", "Blue": "Blue", "Purple": "Purple", "Pink": "Pink",
                
                # Items (Sizes/Shapes)
                "Large": "Large", "Huge": "Huge", "Gigantic": "Gigantic",
                "Square": "Square", "Triangle": "Triangle",
                
                # Gameplay
                "COMBO": "Combo:", "MISSED": "Missed:", "SPEED": "Speed:", "PLATFORM": "Platform:",
                "SELECT_SONG": "Select Song"
            },
            "UA": {
                # Main Menu (Shortened words to fit UI)
                "START": "ГРАТИ", "RHYTHM": "РИТМ", "SHOP": "МАГАЗИН", "SETTINGS": "ОПЦІЇ", "QUIT": "ВИХІД",
                "LANG": "МОВА: UA", "LIGHT": "СВІТЛА", "DARK": "ТЕМНА",
                
                # General
                "BACK": "НАЗАД", "RESET": "СКИНУТИ", "GAME_OVER": "КІНЕЦЬ ГРИ", 
                "SCORE": "Рахунок:", "HIGH_SCORE": "Рекорд:", 
                "RETRY": "ЗНОВУ", "MENU": "МЕНЮ", "PAUSED": "ПАУЗА",
                "RESUME": "ДАЛІ", "NO_MUSIC": "НЕМАЄ МУЗИКИ", "ARE_YOU_SURE": "Ви впевнені?",
                "YES": "ТАК", "NO": "НІ",
                
                # Settings (Shortened words)
                "AUDIO": "АУДІО", "DIFFICULTY": "РІВЕНЬ",
                "MUSIC_VOL": "Музика:", "SFX_VOL": "Звуки:",
                "EASY": "Легко", "NORMAL": "Норм", "HARD": "Важко",
                
                # Shop
                "TAB_COLORS": "Кольори", "TAB_SIZES": "Розмір", "TAB_SHAPES": "Форми",
                "CURRENCY": "Гроші:", "OWNED": "Є ВЖЕ", "EQUIPPED": "ВЗЯТО",
                
                # Items (Colors)
                "Red": "Червоний", "Orange": "Оранж", "Yellow": "Жовтий", "Green": "Зелений", 
                "Cyan": "Блакитний", "Blue": "Синій", "Purple": "Фіолет", "Pink": "Рожевий",
                
                # Items (Sizes/Shapes)
                "Large": "Великий", "Huge": "Велет", "Gigantic": "Гігант",
                "Square": "Квадрат", "Triangle": "Трикутник",
                
                # Gameplay
                "COMBO": "Комбо:", "MISSED": "Пропуск:", "SPEED": "Швидк.:", "PLATFORM": "Платф.:",
                "SELECT_SONG": "Обери пісню"
            }
        }

    def get(self, key: str) -> str:
        """
        @brief Retrieves the localized string for a given key.
        @param key The key to look up (e.g., "START").
        @return The translated string, or the key itself if not found.
        """
        return self.translations[self.current_lang].get(key, key)

    def toggle_lang(self):
        """
        @brief Toggles the language between English (EN) and Ukrainian (UA).
        """
        self.current_lang = "UA" if self.current_lang == "EN" else "EN"
        logging.info(f"Language switched to {self.current_lang}")

# Global instance (Singleton pattern via module level variable)
loc = LocalizationManager()

# --- HELPER FUNCTIONS ---
def clamp(value, min_val, max_val):
    """
    @brief Clamps a value between a minimum and maximum.
    """
    return max(min_val, min(value, max_val))

def draw_text(surf, text, font, x, y, color, align="center"):
    """
    @brief Utility function to draw text on a surface.
    @param surf The Pygame surface to draw on.
    @param text The string to render.
    @param font The Pygame font object to use.
    @param x The x-coordinate.
    @param y The y-coordinate.
    @param color The text color (RGB tuple).
    @param align The alignment relative to (x, y). Options: "center", "topleft", "topright", "left".
    """
    text_surface = font.render(str(text), True, color)
    text_rect = text_surface.get_rect()
    if align == "center": text_rect.midtop = (x, y)
    elif align == "topleft": text_rect.topleft = (x, y)
    elif align == "topright": text_rect.topright = (x, y)
    elif align == "left": text_rect.midleft = (x, y)
    surf.blit(text_surface, text_rect)

# --- THEME MANAGER ---
class ThemeManager:
    """
    @brief Manages visual themes and smooth transitions between them.
    @details Handles "dark" and "light" themes, defining colors, background elements, and particle effects.
    """
    def __init__(self):
        """
        @brief Initializes the theme manager with the default 'dark' theme.
        """
        self.current_theme = "dark"
        self.transition_alpha = 0
        self.is_transitioning = False
        self.target_theme = ""
        self.transition_speed = 15
        
        # Pre-generate clouds for the light theme
        self.light_clouds = []
        for _ in range(15):
             self.light_clouds.append({ "type": "cloud", "x": random.randint(0, WIDTH), "y": random.randint(-150, HEIGHT), "size": random.randint(15, 35), "speed": random.uniform(0.2, 0.6), "alpha": random.randint(40, 90), "sway_speed": random.uniform(0.5, 1.5), "sway_amp": random.randint(5, 15) })
        for _ in range(7): 
            self.light_clouds.append({ "type": "cloud", "x": random.randint(0, WIDTH), "y": random.randint(-150, HEIGHT), "size": random.randint(60, 120), "speed": random.uniform(0.6, 1.3), "alpha": random.randint(120, 200), "sway_speed": random.uniform(0.5, 1.5), "sway_amp": random.randint(10, 40) })

        self.themes = {
            "dark": {
                "bg_color": (20, 20, 45), "text_color": (240, 240, 250), "platform_color": (100, 149, 237), "particle_color": (255, 255, 204),
                "btn_color": (60, 40, 90), "btn_hover": (80, 60, 110), "btn_active": (100, 70, 140), "btn_text_color": (255, 255, 255),
                "slider_line": (150, 150, 180), "slider_knob": (255, 255, 255), "modal_bg": (30, 30, 60),
                "bg_elements": [ {"type": "wave", "color": (60, 20, 80, 100), "amp": 70, "freq": 0.012, "speed": 0.3, "y": 610}, {"type": "wave", "color": (80, 60, 140, 100), "amp": 50, "freq": 0.007, "speed": -0.45, "y": 620}, {"type": "wave", "color": (40, 40, 100, 100), "amp": 30, "freq": 0.01, "speed": 0.6, "y": 600} ],
                "has_bg_stars": True, "star_style": "glow" 
            },
            "light": {
                "bg_color": BOHO_BG, "text_color": (255, 255, 255), "platform_color": (20, 50, 100), "particle_color": None,
                "btn_color": (20, 50, 100), "btn_hover": (40, 70, 130), "btn_active": (65, 105, 225), "btn_text_color": (255, 255, 255),
                "slider_line": (255, 255, 255), "slider_knob": (20, 50, 100), "modal_bg": (135, 206, 250),
                "bg_elements": self.light_clouds, "has_bg_stars": False, "star_style": "ball"
            }
        }
        self.light_theme_star_colors = [ (255, 105, 180), (50, 205, 50), (255, 215, 0), (255, 69, 0) ]
        self.shop_colors = SHOP_COLORS

    def get(self, key): 
        """
        @brief Returns a property from the current active theme.
        @param key The theme property key (e.g., "bg_color").
        """
        return self.themes[self.current_theme][key]
    
    def start_transition(self):
        """
        @brief Initiates a visual transition between Dark and Light themes.
        """
        self.target_theme = "light" if self.current_theme == "dark" else "dark"
        self.is_transitioning = True
        self.transition_alpha = 0
        logging.info(f"Transitioning theme to {self.target_theme}")

    def update(self):
        """
        @brief Updates the theme transition animation.
        @return True if the theme was swapped this frame, False otherwise.
        """
        switched = False
        if self.is_transitioning:
            if self.current_theme != self.target_theme:
                self.transition_alpha += self.transition_speed
                if self.transition_alpha >= 255:
                    self.transition_alpha = 255
                    self.current_theme = self.target_theme
                    switched = True
            else:
                self.transition_alpha -= self.transition_speed
                if self.transition_alpha <= 0:
                    self.transition_alpha = 0
                    self.is_transitioning = False
        return switched

    def draw_transition(self, surface):
        """
        @brief Draws the full-screen fade effect during theme transition.
        @param surface The screen surface.
        """
        if self.is_transitioning:
            overlay = pygame.Surface((WIDTH, HEIGHT))
            overlay.fill(BLACK)
            overlay.set_alpha(self.transition_alpha)
            surface.blit(overlay, (0, 0))

theme_mgr = ThemeManager()

# --- ABSTRACT CLASSES ---

class GameObject(ABC):
    """
    @brief Abstract base class for all game objects.
    @details Enforces the implementation of update and draw methods.
    """
    @abstractmethod
    def update(self, dt, **kwargs): 
        """
        @brief Updates the object state.
        @param dt Delta time (time since last frame in seconds).
        @param kwargs Additional context arguments (e.g., input keys, mouse pos).
        """
        pass
    
    @abstractmethod
    def draw(self, surface): 
        """
        @brief Draws the object to the screen.
        @param surface The Pygame surface to render on.
        """
        pass

class UIElement(GameObject):
    """
    @brief Base class for User Interface elements.
    """
    def __init__(self, x, y, w, h): self._rect = pygame.Rect(x, y, w, h)
    def update(self, dt, **kwargs): pass

class GameState(ABC):
    """
    @brief Abstract base class for game states (State Pattern).
    @details Represents a specific screen or mode (Menu, Playing, Shop).
    """
    def __init__(self, game): self._game = game
    
    @abstractmethod
    def handle_event(self, event): 
        """
        @brief Handles Pygame events for this state.
        @param event The Pygame event object.
        """
        pass
        
    @abstractmethod
    def update(self, dt): pass
    @abstractmethod
    def draw(self, surface): pass

T = TypeVar('T', bound=GameObject)
class ObjectManager(Generic[T]):
    """
    @brief Generic manager for collections of game objects.
    @details Handles adding, removing, updating, and drawing a list of objects.
    @tparam T The type of GameObject this manager holds.
    """
    def __init__(self): self._objects: List[T] = []
    
    def add(self, obj: T): 
        """ @brief Adds an object to the manager. """
        self._objects.append(obj)
        
    def remove(self, obj: T): 
        """ @brief Removes an object from the manager. """
        if obj in self._objects: self._objects.remove(obj)
        
    def get_list(self) -> List[T]: return self._objects[:]
    def clear(self): self._objects.clear()
    
    def update_all(self, dt, **kwargs):
        """ @brief Calls update() on all managed objects. """
        for obj in self._objects[:]: obj.update(dt, **kwargs)
        
    def draw_all(self, surface):
        """ @brief Calls draw() on all managed objects. """
        for obj in self._objects: obj.draw(surface)

# --- GAME OBJECTS ---

class ProceduralWave(GameObject):
    """
    @brief Represents a background element (wave or cloud).
    @details Appearance changes based on the current active theme.
    """
    def __init__(self, index):
        self._index = index
        self._phase = random.uniform(0, 2 * math.pi)
        self._wobble_speed = random.uniform(1.0, 2.0)
        self._update_params_from_theme()

    def _update_params_from_theme(self):
        """ @brief Reloads parameters (color, speed, type) from ThemeManager. """
        elements = theme_mgr.get("bg_elements")
        if self._index < len(elements):
            params = elements[self._index]
            self._type = params["type"]
            self._speed = params["speed"]
            if self._type == "wave":
                self._color = params["color"]
                self._amplitude = params["amp"]
                self._frequency = params["freq"]
                self._y_offset = params["y"]
                self._surface = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
            elif self._type == "cloud":
                self._x_base = params["x"]
                self._y_base = params["y"]
                self._radius = params["size"]
                self._alpha = params.get("alpha", 100)
                self._float_speed = params.get("sway_speed", 1.0)
                self._float_amp = params.get("sway_amp", 20)
                self._draw_x = self._x_base
                self._draw_y = self._y_base
        else:
            self._type = "none"
            self._speed = 0

    def update(self, dt, **kwargs):
        if kwargs.get("theme_switched"): self._update_params_from_theme()
        self._phase += self._speed * dt
        if self._type == "cloud":
            self._y_base += self._speed * 60 * dt
            if self._y_base > HEIGHT + self._radius * 2: 
                self._y_base = -self._radius * 2
                self._x_base = random.randint(0, WIDTH)
            current_time = pygame.time.get_ticks() / 1000.0
            sway_offset = math.sin(current_time * self._float_speed + self._index) * self._float_amp
            self._draw_x = self._x_base + sway_offset
            self._draw_y = self._y_base

    def draw(self, surface):
        if self._type == "wave":
            self._surface.fill((0, 0, 0, 0))
            points = []
            for x in range(WIDTH + 1):
                y = self._amplitude * math.sin(self._frequency * x + self._phase) + self._y_offset
                points.append((x, y))
            points.append((WIDTH, HEIGHT))
            points.append((0, HEIGHT))
            pygame.draw.polygon(self._surface, self._color, points)
            surface.blit(self._surface, (0, 0))
        elif self._type == "cloud":
            pulse = math.sin(self._phase * self._wobble_speed) * 3
            current_radius = self._radius + pulse
            surf_size = int(current_radius * 3) 
            cloud_surf = pygame.Surface((surf_size, surf_size), pygame.SRCALPHA)
            center = (surf_size // 2, surf_size // 2)
            outer_radius = current_radius * 1.5
            inner_radius = current_radius * 0.7
            outer_color = (255, 255, 255, int(self._alpha * 0.4))
            inner_color = (255, 255, 255, self._alpha)
            pygame.draw.circle(cloud_surf, outer_color, center, int(outer_radius))
            pygame.draw.circle(cloud_surf, inner_color, center, int(inner_radius))
            surface.blit(cloud_surf, (self._draw_x - surf_size // 2, self._draw_y - surf_size // 2))

class Particle(GameObject):
    """
    @brief A temporary visual particle effect.
    """
    def __init__(self, x, y, specific_color=None):
        self._x = x; self._y = y
        self._vx = random.uniform(-150, 150); self._vy = random.uniform(-150, 150)
        self._size = random.uniform(2, 5)
        self._color = specific_color if specific_color else (theme_mgr.get("particle_color") or (255, 255, 255))
        self._lifetime = random.uniform(0.2, 0.5)

    def update(self, dt, **kwargs):
        self._x += self._vx * dt; self._y += self._vy * dt
        self._lifetime -= dt; self._size -= 5 * dt
        return self._lifetime > 0 and self._size > 1

    def draw(self, surface):
        if self._size > 0: pygame.draw.circle(surface, self._color, (self._x, self._y), int(self._size))

class Basket(GameObject):
    """
    @brief The player-controlled paddle/basket.
    @details Handles movement logic and visual customization (size, color).
    """
    def __init__(self, game):
        self._game = game; self._base_width = 150; self._height = 20
        self._x = WIDTH // 2 - self._base_width // 2; self._y = HEIGHT - 80
        self._base_vel = 9; self._vel = self._base_vel

    def _get_current_properties(self):
        size_mod = self._game.get_equipped("size"); color_name = self._game.get_equipped("color")
        width = self._base_width + (size_mod * 30)
        color = theme_mgr.shop_colors.get(color_name) or theme_mgr.get("platform_color")
        return width, color

    def update(self, dt, **kwargs):
        """
        @brief Updates paddle position based on keyboard input.
        @param kwargs Expects 'keys' (pygame.key.get_pressed()) and 'speed_multiplier'.
        """
        width, _ = self._get_current_properties()
        keys = kwargs.get("keys")
        speed_multiplier = kwargs.get("speed_multiplier", 1.0)
        if not keys: return
        calculated_vel = self._base_vel + (speed_multiplier - 1.0) * 3.0
        self._vel = min(MAX_PLATFORM_SPEED, calculated_vel)
        if keys[pygame.K_LEFT] and self._x > 0: self._x -= self._vel
        if keys[pygame.K_RIGHT] and self._x < WIDTH - width: self._x += self._vel

    def get_vel(self) -> float: return self._vel
    def get_rect(self) -> pygame.Rect:
        width, _ = self._get_current_properties()
        return pygame.Rect(self._x, self._y, width, self._height)

    def draw(self, surface):
        width, color = self._get_current_properties()
        rect = pygame.Rect(self._x, self._y, width, self._height)
        pygame.draw.rect(surface, color, rect, border_radius=5)

class Currency(GameObject):
    """
    @brief Falling item that grants currency.
    """
    def __init__(self, speed_multiplier):
        self._x = random.randint(50, WIDTH - 50); self._y = random.randint(-200, -20)
        self._speed = 3.0 * speed_multiplier; self._size = 20; self._angle = 0

    def update(self, dt, **kwargs):
        speed_multiplier = kwargs.get("speed_multiplier", 1.0)
        self._y += self._speed * speed_multiplier; self._angle += 2
        
    def get_y(self) -> float: return self._y
    def get_rect(self) -> pygame.Rect: return pygame.Rect(self._x - self._size, self._y - self._size, self._size*2, self._size*2)

    def draw(self, surface):
        if theme_mgr.current_theme == "dark":
            points = [ (self._x, self._y - self._size), (self._x + self._size/2, self._y), (self._x, self._y + self._size), (self._x - self._size/2, self._y) ]
            pygame.draw.polygon(surface, (255, 255, 100), points)
            pygame.draw.circle(surface, (255, 255, 200, 100), (int(self._x), int(self._y)), int(self._size * 0.8))
        else:
            for i in range(5):
                angle_rad = math.radians(self._angle + i * 72)
                px = self._x + math.cos(angle_rad) * (self._size * 0.6); py = self._y + math.sin(angle_rad) * (self._size * 0.6)
                pygame.draw.circle(surface, (255, 180, 180), (int(px), int(py)), int(self._size * 0.5))
            pygame.draw.circle(surface, (255, 220, 100), (int(self._x), int(self._y)), int(self._size * 0.4))

class Star(GameObject):
    """
    @brief Falling item representing a note or score object.
    @details Can be a random arcade star or a rhythm game note (with a trail).
    """
    def __init__(self, speed_multiplier, game_ref, fixed_x=None, note_name=None):
        self._game = game_ref
        if fixed_x is not None:
            self._x = fixed_x; self._is_rhythm_note = True
        else:
            self._x = random.randint(100, WIDTH - 100); self._is_rhythm_note = False
            
        self._y = random.randint(-200, -20)
        self._z = random.uniform(0.1, 1.0)
        self._base_speed = random.uniform(1.4, 1.6)
        self._vel = self._base_speed * speed_multiplier
        self._base_size = 5 + self._z * 5 
        self._points = int(15 - (self._z * 10))
        self._blink_timer = random.uniform(0, 2 * math.pi)
        self._blink_speed = random.uniform(1.0, 3.0)
        self._trail = []; self._max_trail_length = 15 
        
        self._note_name = note_name

        if theme_mgr.current_theme == "light":
            self._specific_color = random.choice(theme_mgr.light_theme_star_colors)
            self._base_size = 20
        else:
            self._specific_color = None

    def get_note_name(self): return self._note_name

    def get_size_category(self) -> str:
        if self._z > 0.7: return 'large'
        elif self._z > 0.4: return 'medium'
        else: return 'small'
    
    def get_color(self):
        return self._specific_color if self._specific_color else PASTEL_CREAM

    def set_y(self, y): self._y = y

    def update(self, dt, **kwargs):
        speed_multiplier = kwargs.get("speed_multiplier", 1.0)
        rhythm_speed = kwargs.get("speed")
        if self._is_rhythm_note and rhythm_speed: self._vel = rhythm_speed * speed_multiplier
        else: self._vel = self._base_speed * speed_multiplier
        
        self._y += self._vel
        self._blink_timer += self._blink_speed * dt

        if self._is_rhythm_note:
            self._trail.append((self._x, self._y))
            if len(self._trail) > self._max_trail_length: self._trail.pop(0)

    def get_y(self) -> float: return self._y
    def get_points(self) -> int: return self._points
    def get_pos(self) -> tuple[float, float]: return (self._x, self._y)
    def get_rect(self) -> pygame.Rect:
        return pygame.Rect(self._x - self._base_size, self._y - self._base_size, self._base_size * 2, self._base_size * 2)

    def draw(self, surface):
        shape = self._game.get_equipped("shape")
        p = clamp((math.sin(self._blink_timer) * 0.5 + 0.5), 0, 1)
        current_size = self._base_size * (0.8 + p * 0.4) 
        
        if theme_mgr.current_theme == "light":
            base_color = self._specific_color; halo_color = (255, 255, 255); halo_alpha_base = 150 
        else:
            base_color = (255, 229, 180); halo_color = (255, 255, 204); halo_alpha_base = 100

        if self._is_rhythm_note:
             if len(self._trail) > 1:
                for i, (tx, ty) in enumerate(self._trail):
                    alpha = int(150 * (i / len(self._trail)))
                    t_size = int(self._base_size * (i / len(self._trail)) * 0.8)
                    if t_size < 1: t_size = 1
                    s_trail = pygame.Surface((t_size*2, t_size*2), pygame.SRCALPHA)
                    pygame.draw.circle(s_trail, (*base_color, alpha), (t_size, t_size), t_size)
                    surface.blit(s_trail, (tx - t_size, ty - t_size))
             s = pygame.Surface((int(current_size*4), int(current_size*4)), pygame.SRCALPHA)
             pygame.draw.circle(s, (*halo_color, halo_alpha_base), (int(current_size*2), int(current_size*2)), int(current_size*1.6))
             pygame.draw.circle(s, (*base_color, 255), (int(current_size*2), int(current_size*2)), int(current_size))
             surface.blit(s, (self._x - current_size*2, self._y - current_size*2))
        else:
            if shape == "Square":
                rect = pygame.Rect(self._x - current_size, self._y - current_size, current_size*2, current_size*2)
                pygame.draw.rect(surface, base_color, rect)
            elif shape == "Triangle":
                points = [ (self._x, self._y - current_size), (self._x + current_size, self._y + current_size), (self._x - current_size, self._y + current_size) ]
                pygame.draw.polygon(surface, base_color, points)
            else: 
                s = pygame.Surface((int(current_size*4), int(current_size*4)), pygame.SRCALPHA)
                outer_alpha = int(halo_alpha_base * (0.7 + p * 0.3))
                pygame.draw.circle(s, (*halo_color, outer_alpha), (int(current_size*2), int(current_size*2)), int(current_size*1.6))
                pygame.draw.circle(s, (*base_color, 255), (int(current_size*2), int(current_size*2)), int(current_size))
                surface.blit(s, (self._x - current_size*2, self._y - current_size*2))

# --- UI CLASSES ---
class Button(UIElement):
    """
    @brief Clickable UI Button.
    @details Handles translation (i18n), hover states, and click detection.
    """
    def __init__(self, x, y, w, h, text_key, btn_type, font, color_override=None):
        super().__init__(x, y, w, h)
        self._text_key = text_key # Store translation key
        self._btn_type = btn_type; self._is_hovered = False; self._font = font; self._color_override = color_override
    def update(self, dt, **kwargs):
        mouse_pos = kwargs.get("mouse_pos")
        self._is_hovered = self._rect.collidepoint(mouse_pos) if mouse_pos else False
    def draw(self, surface):
        if self._color_override:
             color = self._color_override
             if self._is_hovered: color = (min(255, color[0]+20), min(255, color[1]+20), min(255, color[2]+20))
        else:
            if self._btn_type == "active": color = theme_mgr.get("btn_active")
            elif self._is_hovered: color = theme_mgr.get("btn_hover")
            else: color = theme_mgr.get("btn_color")
        pygame.draw.rect(surface, color, self._rect, border_radius=10)
        text_y = self._rect.centery - self._font.get_height() // 2
        text_col = theme_mgr.get("btn_text_color")
        # Use localization here
        translated_text = loc.get(self._text_key)
        draw_text(surface, translated_text, self._font, self._rect.centerx, text_y, color=text_col)
    
    def check_click(self, event) -> bool: 
        """ @brief Checks if the button was clicked (hovered + mouse down). """
        return event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and self._is_hovered
    
    def set_type(self, btn_type): self._btn_type = btn_type
    def set_text_key(self, key): self._text_key = key

class Slider(UIElement):
    """
    @brief UI Slider for adjusting numerical values.
    """
    def __init__(self, x, y, w, h, min_val, max_val, initial_val, font):
        super().__init__(x, y, w, h)
        self._min_val = min_val; self._max_val = max_val; self._current_val = initial_val; self._font = font; self._is_dragging = False
    
    def handle_event(self, event):
        """ @brief Handles dragging logic. """
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self._rect.collidepoint(event.pos): self._is_dragging = True; self._update_val_from_pos(event.pos[0])
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._is_dragging = False
        elif event.type == pygame.MOUSEMOTION and self._is_dragging: self._update_val_from_pos(event.pos[0])
    
    def _update_val_from_pos(self, mouse_x):
        rel_x = mouse_x - self._rect.x; pct = clamp(rel_x / self._rect.w, 0.0, 1.0)
        self._current_val = self._min_val + pct * (self._max_val - self._min_val)
    
    def get_value(self): return self._current_val
    def draw(self, surface):
        line_col = theme_mgr.get("slider_line"); line_y = self._rect.centery
        pygame.draw.line(surface, line_col, (self._rect.left, line_y), (self._rect.right, line_y), 4)
        pct = (self._current_val - self._min_val) / (self._max_val - self._min_val)
        knob_x = self._rect.left + pct * self._rect.w; knob_col = theme_mgr.get("slider_knob")
        pygame.draw.circle(surface, knob_col, (int(knob_x), int(line_y)), 10)
        txt_col = theme_mgr.get("text_color"); val_percent = int(pct * 100)
        draw_text(surface, f"{val_percent}", self._font, self._rect.right + 15, self._rect.y, color=txt_col, align="left")

class ConfirmationModal:
    """
    @brief Modal popup for confirmation actions (e.g., Quit Game).
    """
    def __init__(self, game):
        self._game = game; self._rect = pygame.Rect(50, 300, 400, 200)
        self._btn_yes = Button(100, 420, 100, 50, "YES", "normal", game.FONT_SMALL) 
        self._btn_no = Button(300, 420, 100, 50, "NO", "normal", game.FONT_SMALL)

    def handle_event(self, event):
        if self._btn_yes.check_click(event): return True
        elif self._btn_no.check_click(event): return False
        return None
    def update(self):
        mouse_pos = pygame.mouse.get_pos()
        self._btn_yes.update(0, mouse_pos=mouse_pos); self._btn_no.update(0, mouse_pos=mouse_pos)
    def draw(self, surface):
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA); overlay.fill((0,0,0, 150)); surface.blit(overlay, (0,0))
        bg_col = theme_mgr.get("modal_bg"); border_col = theme_mgr.get("platform_color"); text_col = theme_mgr.get("text_color")
        if theme_mgr.current_theme == "dark": text_col = WHITE
        pygame.draw.rect(surface, bg_col, self._rect, border_radius=15)
        pygame.draw.rect(surface, border_col, self._rect, width=3, border_radius=15)
        # Assuming YES/NO keys exist or are universal
        draw_text(surface, loc.get("ARE_YOU_SURE"), self._game.FONT_MEDIUM, WIDTH//2, 330, text_col) 
        self._btn_yes.draw(surface); self._btn_no.draw(surface)

# --- GAME STATES ---

class MenuState(GameState):
    """
    @brief The Main Menu state.
    @details Provides access to Play, Shop, Settings, Theme toggle, and Quit.
    """
    def __init__(self, game):
        super().__init__(game)
        self._btn_start = Button(WIDTH//2 - 100, 250, 200, 60, "START", "normal", game.FONT_MEDIUM)
        self._btn_rhythm = Button(30, 340, 200, 60, "RHYTHM", "normal", game.FONT_MEDIUM)
        self._btn_theme = Button(30, 420, 200, 60, "", "normal", game.FONT_MEDIUM)
        self._btn_shop = Button(270, 340, 200, 60, "SHOP", "normal", game.FONT_MEDIUM)
        self._btn_settings = Button(270, 420, 200, 60, "SETTINGS", "normal", game.FONT_MEDIUM)
        self._btn_quit = Button(WIDTH//2 - 100, 520, 200, 60, "QUIT", "normal", game.FONT_MEDIUM)
        self._buttons = [self._btn_start, self._btn_rhythm, self._btn_shop, self._btn_settings, self._btn_theme, self._btn_quit]
        self._confirm_modal = None
        self._update_theme_btn()

    def _update_theme_btn(self):
        # We want to display the target state or current state. 
        # If current is Dark, button text "LIGHT" (meaning switch to light)
        target_key = "LIGHT" if theme_mgr.current_theme == "dark" else "DARK"
        self._btn_theme.set_text_key(target_key)

    def handle_event(self, event):
        if self._confirm_modal:
            res = self._confirm_modal.handle_event(event)
            if res is True: self._game.stop()
            elif res is False: self._confirm_modal = None
            return
        if self._btn_start.check_click(event): self._game.change_state(PlayingState(self._game))
        elif self._btn_rhythm.check_click(event): self._game.change_state(RhythmSelectionState(self._game))
        elif self._btn_shop.check_click(event): self._game.change_state(ShopState(self._game))
        elif self._btn_settings.check_click(event): self._game.change_state(SettingsState(self._game))
        elif self._btn_theme.check_click(event): theme_mgr.start_transition()
        elif self._btn_quit.check_click(event): self._confirm_modal = ConfirmationModal(self._game)
        self._update_theme_btn()

    def update(self, dt):
        if self._confirm_modal: self._confirm_modal.update(); return
        mouse_pos = pygame.mouse.get_pos()
        for btn in self._buttons: btn.update(dt, mouse_pos=mouse_pos)

    def draw(self, surface):
        draw_text(surface, "Retinal", self._game.FONT_BIG, WIDTH // 2, 150, color=theme_mgr.get("text_color"))
        for btn in self._buttons: btn.draw(surface)
        if self._confirm_modal: self._confirm_modal.draw(surface)

class ShopState(GameState):
    """
    @brief The In-Game Shop state.
    @details Allows buying and equipping colors, sizes, and shapes using virtual currency.
    """
    def __init__(self, game):
        super().__init__(game)
        self._current_tab = "Colors"
        self._btn_back = Button(WIDTH//2 - 100, 720, 200, 50, "BACK", "normal", game.FONT_MEDIUM)
        self._btn_tab_colors = Button(20, 100, 140, 40, "TAB_COLORS", "normal", game.FONT_SMALL)
        self._btn_tab_sizes = Button(180, 100, 140, 40, "TAB_SIZES", "normal", game.FONT_SMALL)
        self._btn_tab_shapes = Button(340, 100, 140, 40, "TAB_SHAPES", "normal", game.FONT_SMALL)
        self._btn_reset = Button(WIDTH//2 - 100, 650, 200, 40, "RESET", "normal", game.FONT_SMALL)
        self._tabs = [self._btn_tab_colors, self._btn_tab_sizes, self._btn_tab_shapes]
        self._items = []
        self._create_item_buttons()
        
    def _create_item_buttons(self):
        self._items = []
        game = self._game
        if self._current_tab == "Colors":
            items = [("Red", 10), ("Orange", 20), ("Yellow", 30), ("Green", 40), ("Cyan", 50), ("Blue", 60), ("Purple", 70), ("Pink", 80)]
            for i, (name, price) in enumerate(items):
                x = 50 if i % 2 == 0 else 260; y = 180 + (i // 2) * 120
                self._items.append(ShopItemButton(x, y, 190, 100, name, price, "color", game))
        elif self._current_tab == "Sizes":
            items = [("Large", 100, 1), ("Huge", 250, 2), ("Gigantic", 500, 3)]
            for i, (name, price, val) in enumerate(items):
                y = 180 + i * 120
                self._items.append(ShopItemButton(100, y, 300, 100, name, price, "size", game, val=val))
        elif self._current_tab == "Shapes":
            items = [("Square", 200), ("Triangle", 300)]
            for i, (name, price) in enumerate(items):
                y = 180 + i * 120
                self._items.append(ShopItemButton(100, y, 300, 100, name, price, "shape", game))

    def handle_event(self, event):
        if self._btn_back.check_click(event): self._game.change_state(MenuState(self._game))
        if self._btn_reset.check_click(event):
            self._game.equip_item("color", "Default"); self._game.equip_item("size", 0); self._game.equip_item("shape", "Star")
        if self._btn_tab_colors.check_click(event): self._current_tab = "Colors"; self._create_item_buttons()
        elif self._btn_tab_sizes.check_click(event): self._current_tab = "Sizes"; self._create_item_buttons()
        elif self._btn_tab_shapes.check_click(event): self._current_tab = "Shapes"; self._create_item_buttons()
        for item in self._items: item.handle_event(event)

    def update(self, dt):
        mouse_pos = pygame.mouse.get_pos()
        self._btn_back.update(dt, mouse_pos=mouse_pos); self._btn_reset.update(dt, mouse_pos=mouse_pos)
        for tab in self._tabs: tab.update(dt, mouse_pos=mouse_pos)
        for item in self._items: item.update(dt, mouse_pos=mouse_pos)

    def draw(self, surface):
        txt_col = theme_mgr.get("text_color")
        # Translate current tab name for display
        tab_key = f"TAB_{self._current_tab.upper()}"
        draw_text(surface, f"{loc.get('SHOP')} - {loc.get(tab_key)}", self._game.FONT_MEDIUM, WIDTH // 2, 30, color=txt_col)
        draw_text(surface, f"{loc.get('CURRENCY')} {self._game.get_currency()}", self._game.FONT_SMALL, WIDTH - 100, 30, GOLD)
        self._btn_back.draw(surface); self._btn_reset.draw(surface)
        for tab in self._tabs: tab.draw(surface)
        for item in self._items: item.draw(surface)

class ShopItemButton(UIElement):
    """
    @brief A button representing an item in the shop.
    """
    def __init__(self, x, y, w, h, name, price, category, game, val=None):
        super().__init__(x, y, w, h)
        self._name = name; self._price = price; self._category = category; self._game = game; self._val = val if val is not None else name; self._is_hovered = False
    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and self._is_hovered:
            if self._game.has_item(self._category, self._val): self._game.equip_item(self._category, self._val)
            else: self._game.buy_item(self._category, self._val, self._price)
    def update(self, dt, **kwargs):
        mouse_pos = kwargs.get("mouse_pos")
        self._is_hovered = self._rect.collidepoint(mouse_pos) if mouse_pos else False
    def draw(self, surface):
        color = (50, 50, 80); 
        if self._is_hovered: color = (70, 70, 100)
        pygame.draw.rect(surface, color, self._rect, border_radius=10)
        owned = self._game.has_item(self._category, self._val); equipped = self._game.is_equipped(self._category, self._val)
        status_text = f"{self._price}"; status_color = WHITE
        if equipped: status_text = loc.get("EQUIPPED"); status_color = GREEN_BUY
        elif owned: status_text = loc.get("OWNED"); status_color = (150, 255, 150)
        elif self._game.get_currency() < self._price: status_color = RED_ERROR
        # Translate name
        draw_text(surface, loc.get(self._name), self._game.FONT_SMALL, self._rect.centerx, self._rect.top + 20, WHITE)
        draw_text(surface, status_text, self._game.FONT_TINY, self._rect.centerx, self._rect.bottom - 30, status_color)

class RhythmSelectionState(GameState):
    """
    @brief Song selection screen for Rhythm Mode.
    """
    def __init__(self, game):
        super().__init__(game)
        self._buttons = []
        # --- PATHS ---
        # SONG_LIST define above
        start_y = 250
        from __main__ import SONG_LIST
        for i, song in enumerate(SONG_LIST):
            btn = Button(WIDTH//2 - 150, start_y + i * 80, 300, 60, song["name"], "normal", game.FONT_SMALL)
            self._buttons.append(btn)
        self._btn_back = Button(WIDTH//2 - 100, 650, 200, 50, "BACK", "normal", game.FONT_MEDIUM)
        self._buttons.append(self._btn_back)

    def handle_event(self, event):
        if self._btn_back.check_click(event): self._game.change_state(MenuState(self._game))
        from __main__ import SONG_LIST
        for i, btn in enumerate(self._buttons[:-1]):
            if btn.check_click(event):
                selected_song = SONG_LIST[i]
                self._game.change_state(RhythmGameState(self._game, selected_song))

    def update(self, dt):
        mouse_pos = pygame.mouse.get_pos()
        for btn in self._buttons: btn.update(dt, mouse_pos=mouse_pos)

    def draw(self, surface):
        txt_col = theme_mgr.get("text_color")
        draw_text(surface, loc.get("SELECT_SONG"), self._game.FONT_MEDIUM, WIDTH // 2, 150, color=txt_col)
        for btn in self._buttons: btn.draw(surface)

class SettingsState(GameState):
    """
    @brief Settings screen (Audio, Difficulty, Language).
    """
    def __init__(self, game):
        super().__init__(game)
        self._current_view = "main"
        self._btn_to_audio = Button(WIDTH//2 - 100, 300, 200, 50, "AUDIO", "normal", game.FONT_MEDIUM)
        self._btn_to_diff = Button(WIDTH//2 - 100, 370, 200, 50, "DIFFICULTY", "normal", game.FONT_MEDIUM)
        self._btn_lang = Button(WIDTH//2 - 100, 440, 200, 50, "LANG", "normal", game.FONT_MEDIUM)
        self._btn_back_main = Button(WIDTH//2 - 100, 600, 200, 50, "BACK", "normal", game.FONT_MEDIUM)
        self._slider_music = Slider(100, 300, 300, 20, 0.0, 1.0, pygame.mixer.music.get_volume(), game.FONT_TINY)
        self._slider_sfx = Slider(100, 400, 300, 20, 0.0, 1.0, game.sfx_volume, game.FONT_TINY)
        self._btn_back_sub = Button(WIDTH//2 - 100, 600, 200, 50, "BACK", "normal", game.FONT_MEDIUM)
        self._btn_easy = Button(WIDTH//2 - 100, 300, 200, 50, "EASY", "normal", game.FONT_SMALL)
        self._btn_medium = Button(WIDTH//2 - 100, 370, 200, 50, "NORMAL", "normal", game.FONT_SMALL)
        self._btn_hard = Button(WIDTH//2 - 100, 440, 200, 50, "HARD", "normal", game.FONT_SMALL)
        self._update_button_states()

    def _update_button_states(self):
        settings = self._game.get_settings()
        self._btn_easy.set_type("active" if settings["star_rate_name"] == "Easy" else "normal")
        self._btn_medium.set_type("active" if settings["star_rate_name"] == "Normal" else "normal")
        self._btn_hard.set_type("active" if settings["star_rate_name"] == "Hard" else "normal")

    def handle_event(self, event):
        self._update_button_states()
        if self._current_view == "main":
            if self._btn_to_audio.check_click(event): self._current_view = "audio"
            elif self._btn_to_diff.check_click(event): self._current_view = "difficulty"
            elif self._btn_lang.check_click(event): 
                loc.toggle_lang()
                self._game._load_fonts() # Reload fonts
                self._btn_lang.set_text_key("LANG")
            elif self._btn_back_main.check_click(event): self._game.change_state(MenuState(self._game))
        elif self._current_view == "audio":
            self._slider_music.handle_event(event); self._slider_sfx.handle_event(event)
            pygame.mixer.music.set_volume(self._slider_music.get_value())
            self._game.sfx_volume = self._slider_sfx.get_value()
            if self._btn_back_sub.check_click(event): self._current_view = "main"
        elif self._current_view == "difficulty":
            settings = self._game.get_settings()
            if self._btn_easy.check_click(event): settings["star_rate"] = 130; settings["star_rate_name"] = "Easy"
            elif self._btn_medium.check_click(event): settings["star_rate"] = 100; settings["star_rate_name"] = "Normal"
            elif self._btn_hard.check_click(event): settings["star_rate"] = 80; settings["star_rate_name"] = "Hard"
            elif self._btn_back_sub.check_click(event): self._current_view = "main"

    def update(self, dt):
        mouse_pos = pygame.mouse.get_pos()
        if self._current_view == "main":
            for btn in [self._btn_to_audio, self._btn_to_diff, self._btn_lang, self._btn_back_main]: btn.update(dt, mouse_pos=mouse_pos)
        elif self._current_view == "audio": self._btn_back_sub.update(dt, mouse_pos=mouse_pos)
        elif self._current_view == "difficulty":
            for btn in [self._btn_easy, self._btn_medium, self._btn_hard, self._btn_back_sub]: btn.update(dt, mouse_pos=mouse_pos)

    def draw(self, surface):
        txt_col = theme_mgr.get("text_color")
        if self._current_view == "main":
            draw_text(surface, loc.get("SETTINGS"), self._game.FONT_BIG, WIDTH // 2, 150, color=txt_col)
            self._btn_to_audio.draw(surface); self._btn_to_diff.draw(surface); self._btn_lang.draw(surface); self._btn_back_main.draw(surface)
        elif self._current_view == "audio":
            draw_text(surface, loc.get("AUDIO"), self._game.FONT_MEDIUM, WIDTH // 2, 150, color=txt_col)
            draw_text(surface, loc.get("MUSIC_VOL"), self._game.FONT_SMALL, WIDTH // 2, 270, color=txt_col)
            self._slider_music.draw(surface)
            draw_text(surface, loc.get("SFX_VOL"), self._game.FONT_SMALL, WIDTH // 2, 370, color=txt_col)
            self._slider_sfx.draw(surface)
            self._btn_back_sub.draw(surface)
        elif self._current_view == "difficulty":
            draw_text(surface, loc.get("DIFFICULTY"), self._game.FONT_MEDIUM, WIDTH // 2, 150, color=txt_col)
            self._btn_easy.draw(surface); self._btn_medium.draw(surface); self._btn_hard.draw(surface); self._btn_back_sub.draw(surface)

class GameOverState(GameState):
    """
    @brief Game Over screen.
    @details Displays score, high score, and options to retry or exit.
    """
    def __init__(self, game, score, song_data=None):
        super().__init__(game)
        self._score = score
        self._game.update_high_score(score)
        self._high_score = self._game.get_high_score()
        self._btn_retry = Button(WIDTH//2 - 100, 400, 200, 50, "RETRY", "normal", game.FONT_MEDIUM)
        self._btn_menu = Button(WIDTH//2 - 100, 470, 200, 50, "MENU", "normal", game.FONT_MEDIUM)
        self._song_data = song_data

    def handle_event(self, event):
        if self._btn_retry.check_click(event):
            if self._song_data:
                self._game.change_state(RhythmGameState(self._game, self._song_data))
            else:
                self._game.change_state(PlayingState(self._game))
        elif self._btn_menu.check_click(event):
            self._game.change_state(MenuState(self._game))

    def update(self, dt):
        mouse_pos = pygame.mouse.get_pos()
        self._btn_retry.update(dt, mouse_pos=mouse_pos)
        self._btn_menu.update(dt, mouse_pos=mouse_pos)

    def draw(self, surface):
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 200))
        surface.blit(overlay, (0, 0))
        draw_text(surface, loc.get("GAME_OVER"), self._game.FONT_BIG, WIDTH // 2, 150, RED_ERROR)
        draw_text(surface, f"{loc.get('SCORE')} {self._score}", self._game.FONT_MEDIUM, WIDTH // 2, 250, WHITE)
        draw_text(surface, f"{loc.get('HIGH_SCORE')} {self._high_score}", self._game.FONT_SMALL, WIDTH // 2, 300, (255, 215, 0))
        self._btn_retry.draw(surface)
        self._btn_menu.draw(surface)

class PausedState(GameState):
    """
    @brief Pause screen overlay.
    """
    def __init__(self, game, previous_state):
        super().__init__(game)
        self._previous_state = previous_state
        self._font = game.FONT_BIG
        self._btn_resume = Button(WIDTH//2 - 100, HEIGHT//2 - 30, 200, 60, "RESUME", "normal", game.FONT_MEDIUM)
        self._btn_menu = Button(WIDTH//2 - 100, HEIGHT//2 + 50, 200, 60, "MENU", "normal", game.FONT_MEDIUM)

    def handle_event(self, event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
             pygame.mixer.music.unpause()
             self._game.change_state(self._previous_state)
        
        if self._btn_resume.check_click(event):
            pygame.mixer.music.unpause()
            self._game.change_state(self._previous_state)
        elif self._btn_menu.check_click(event):
            pygame.mixer.music.set_volume(0.5)
            self._game.change_state(MenuState(self._game))

    def update(self, dt):
        mouse_pos = pygame.mouse.get_pos()
        self._btn_resume.update(dt, mouse_pos=mouse_pos)
        self._btn_menu.update(dt, mouse_pos=mouse_pos)

    def draw(self, surface):
        self._previous_state.draw(surface)
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_text(surface, loc.get("PAUSED"), self._font, WIDTH // 2, HEIGHT // 3, WHITE)
        self._btn_resume.draw(surface); self._btn_menu.draw(surface)

class PlayingState(GameState):
    """
    @brief Standard Arcade Game Mode.
    @details Endless mode with random falling stars.
    """
    def __init__(self, game):
        super().__init__(game)
        self._basket = Basket(game)
        self._star_manager = ObjectManager[GameObject]()
        self._particle_manager = ObjectManager[Particle]()
        self.reset_game()

    def reset_game(self):
        """ @brief Resets score and game objects for a new run. """
        self._score = 0; self._combo = 0; self._missed_stars = 0
        self._speed_multiplier = 1.0; self._star_add_counter = 0
        self._current_add_rate = self._game.get_settings()["star_rate"]
        self._star_manager.clear(); self._particle_manager.clear()

    def handle_event(self, event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            self._game.change_state(PausedState(self._game, self))

    def _spawn_stars(self):
        """ @brief Spawns stars or currency based on timer. """
        self._star_add_counter += 1
        if self._star_add_counter >= self._current_add_rate:
            self._star_add_counter = 0
            if random.random() < 0.05: self._star_manager.add(Currency(self._speed_multiplier))
            else:
                num_to_spawn = 1
                if self._speed_multiplier > 3.5: num_to_spawn = 3
                elif self._speed_multiplier > 2.0: num_to_spawn = 2
                for _ in range(num_to_spawn):
                    self._star_manager.add(Star(self._speed_multiplier, self._game))

    def _handle_collisions(self):
        """ @brief Checks collisions between basket and stars. """
        basket_rect = self._basket.get_rect()
        for obj in self._star_manager.get_list()[:]:
            if obj.get_y() > HEIGHT:
                self._star_manager.remove(obj)
                if isinstance(obj, Star):
                    self._missed_stars += 1
                    self._score = max(0, self._score - 5)
                    if self._missed_stars >= MAX_MISSED_STARS:
                        self._game.update_high_score(self._score)
                        self._game.change_state(GameOverState(self._game, self._score))
                        return
            elif obj.get_rect().colliderect(basket_rect):
                if isinstance(obj, Currency):
                    self._game.add_currency(1); self._game.play_catch_sound() 
                elif isinstance(obj, Star):
                    self._game.play_catch_sound()
                    self._score += obj.get_points() + self._combo
                    self._combo += 1
                    if self._speed_multiplier < 5.0: self._speed_multiplier = min(self._speed_multiplier + 0.03, 5.0)
                    num_particles = random.randint(8, 12)
                    star_pos = obj.get_pos()
                    star_color = obj.get_color()
                    for _ in range(num_particles): self._particle_manager.add(Particle(star_pos[0], star_pos[1], star_color))
                self._star_manager.remove(obj)

    def update(self, dt):
        keys = pygame.key.get_pressed()
        self._basket.update(dt, keys=keys, speed_multiplier=self._speed_multiplier)
        self._spawn_stars()
        self._star_manager.update_all(dt, speed_multiplier=self._speed_multiplier)
        self._handle_collisions()
        for particle in self._particle_manager.get_list()[:]:
            if not particle.update(dt): self._particle_manager.remove(particle)

    def draw(self, surface):
        self._basket.draw(surface)
        self._star_manager.draw_all(surface)
        self._particle_manager.draw_all(surface)
        txt_col = theme_mgr.get("text_color")
        draw_text(surface, f"{loc.get('SCORE')} {self._score}", self._game.FONT_MEDIUM, 60, 20, color=txt_col, align="topleft")
        draw_text(surface, f"{loc.get('COMBO')} x{self._combo}", self._game.FONT_SMALL, 60, 60, color=txt_col, align="topleft")
        missed_text = f"{loc.get('MISSED')} {self._missed_stars}/{MAX_MISSED_STARS}"
        draw_text(surface, missed_text, self._game.FONT_SMALL, 60, 100, color=RED_ERROR, align="topleft")
        draw_text(surface, f"{loc.get('SPEED')} {self._speed_multiplier:.2f}x", self._game.FONT_TINY, WIDTH - 80, 20, color=txt_col, align="topright")
        draw_text(surface, f"{loc.get('PLATFORM')} {self._basket.get_vel():.1f}", self._game.FONT_TINY, WIDTH - 80, 50, color=txt_col, align="topright")

class RhythmGameState(GameState):
    """
    @brief Rhythm Game Mode.
    @details Notes fall according to BPM. Music is played via note hits (Piano Tiles style).
    """
    def __init__(self, game, song_data):
        super().__init__(game)
        self._basket = Basket(game)
        self._star_manager = ObjectManager[Star]()
        self._particle_manager = ObjectManager[Particle]()
        self._song_data = song_data
        self._bpm = song_data["bpm"]
        self._beat_interval = 60.0 / self._bpm
        self._next_beat_time = 0
        self._timer = 0.0
        self._speed = 5.0
        self._score = 0
        self._is_playing = True
        
        # --- LOAD NOTES ---
        note_id = song_data.get("note_id")
        self._note_sequence = game.notes_data.get(note_id, [])
        self._current_note_index = 0
        
        # Stop background music in this mode
        pygame.mixer.music.stop()

    def handle_event(self, event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self._game.change_state(MenuState(self._game))
        elif event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            pygame.mixer.music.pause()
            self._game.change_state(PausedState(self._game, self))

    def update(self, dt):
        keys = pygame.key.get_pressed()
        self._basket.update(dt, keys=keys, speed_multiplier=1.2)
        self._timer += dt
        
        # Spawn notes on beat
        if self._timer >= self._next_beat_time:
            self._spawn_rhythm_note()
            self._next_beat_time += self._beat_interval * 2
            
        self._star_manager.update_all(dt, speed_multiplier=1.0)
        
        basket_rect = self._basket.get_rect()
        for star in self._star_manager.get_list()[:]:
            if star.get_y() > HEIGHT:
                # Missed note
                self._game.update_high_score(self._score)
                self._game.change_state(GameOverState(self._game, self._score, self._song_data))
                return
            elif star.get_rect().colliderect(basket_rect):
                # Caught note
                note_name = star.get_note_name()
                if note_name:
                    self._game.play_note_sound(note_name) # Play specific note sound
                
                self._score += 10
                star_pos = star.get_pos()
                star_color = star.get_color()
                for _ in range(10):
                    self._particle_manager.add(Particle(star_pos[0], star_pos[1], star_color))
                self._star_manager.remove(star)
        
        for particle in self._particle_manager.get_list()[:]:
            if not particle.update(dt): self._particle_manager.remove(particle)

    def _spawn_rhythm_note(self):
        """ @brief Creates a note object at a random lane for the next beat. """
        lane_x = random.choice(LANE_CENTERS)
        
        note_name = None
        if self._note_sequence:
            note_name = self._note_sequence[self._current_note_index]
            self._current_note_index = (self._current_note_index + 1) % len(self._note_sequence)

        star = Star(self._speed, self._game, fixed_x=int(lane_x), note_name=note_name)
        star.set_y(-50)
        self._star_manager.add(star)

    def draw(self, surface):
        self._basket.draw(surface)
        self._star_manager.draw_all(surface)
        self._particle_manager.draw_all(surface)
        txt_col = theme_mgr.get("text_color")
        draw_text(surface, f"Score: {self._score}", self._game.FONT_MEDIUM, 60, 20, color=txt_col, align="topleft")

class Game:
    """
    @brief Main Game Controller.
    @details Handles initialization, asset loading, main loop, and global data storage.
    """
    def __init__(self, headless=False):
        """ 
        @brief Initializes Pygame, Mixer, Window, and Game Data.
        @param headless If True, suppresses window creation (useful for testing).
        """
        pygame.mixer.pre_init(44100, -16, 2, 512)
        if not pygame.get_init():
             pygame.init()
        
        if headless:
            self._window = pygame.Surface((WIDTH, HEIGHT)) # Dummy surface
        else:
            self._window = pygame.display.set_mode((WIDTH, HEIGHT))
            pygame.display.set_caption("Retinal")
            
        self._clock = pygame.time.Clock()
        self._running = True
        self._settings = {"star_rate": 100, "star_rate_name": "Normal"}
        self.sfx_volume = 0.5
        self.data = { "high_score": 0, "currency": 0, "inventory": ["Default", "Star", "Default_Size"], "equipped": {"color": "Default", "shape": "Star", "size": 0} }
        self.notes_data = {}
        
        self.sound_bank = {} # Dictionary to store loaded note sounds

        self._load_data()
        self._load_notes()
        
        if self.data["currency"] < 10000: self.data["currency"] = 1000000; self._save_data()

        self._load_fonts()
        self._create_background()
        self._menu_music_path = os.path.join(SOUND_FOLDER, "menu_sound.mp3")
        self._game_music_path = os.path.join(SOUND_FOLDER, "game_sound.mp3")
        self._sound_effect_paths = {"hight": os.path.join(SOUND_FOLDER, "hight.mp3")}
        
        self._current_music_path: Optional[str] = None
        self._catch_sound: Optional[pygame.mixer.Sound] = None
        self._sound_channel_star: Optional[pygame.mixer.Channel] = None
        
        if not headless:
            self._load_audio()
            self._load_all_note_sounds() # Load all notes on startup
            self._current_state: GameState = MenuState(self)
            self.play_music(self._menu_music_path, volume=0.5)
        else:
             self._current_state = None # Headless state

    def _load_data(self):
        """ @brief Loads persistent user data (JSON) with error handling. """
        if os.path.exists(SAVE_FILE):
            try:
                with open(SAVE_FILE, 'r') as f:
                    loaded_data = json.load(f)
                    for key in self.data:
                        if key in loaded_data: self.data[key] = loaded_data[key]
            except json.JSONDecodeError:
                logging.error("Save file is corrupted. Starting with default data.")
            except Exception as e:
                logging.error(f"Error loading save file: {e}")

    def _load_notes(self):
        """ @brief Loads beatmap data (JSON) with error handling. """
        try:
            with open(NOTES_FILE, 'r') as f:
                self.notes_data = json.load(f)
                logging.info("Notes loaded successfully.")
        except FileNotFoundError:
            logging.warning("Warning: notes.json not found. Run note_editor.py first.")
            self.notes_data = {}
        except json.JSONDecodeError:
            logging.error("Notes file is corrupted.")
            self.notes_data = {}

    def _save_data(self):
        """ @brief Saves persistent user data (JSON). """
        try:
            with open(SAVE_FILE, 'w') as f: json.dump(self.data, f)
        except Exception as e: logging.error(f"Error saving data: {e}")

    def update_high_score(self, score):
        if score > self.data["high_score"]:
            self.data["high_score"] = score
            self._save_data()

    def get_high_score(self): return self.data["high_score"]
    def get_currency(self): return self.data["currency"]
    def add_currency(self, amount): self.data["currency"] += amount; self._save_data()
    def has_item(self, category, item_id): return True if item_id in ["Default", "Star", 0] else item_id in self.data["inventory"]
    def buy_item(self, category, item_id, price):
        if self.data["currency"] >= price:
            self.data["currency"] -= price; self.data["inventory"].append(item_id); self._save_data(); return True
        return False
    def equip_item(self, category, item_id): self.data["equipped"][category] = item_id; self._save_data()
    def is_equipped(self, category, item_id): return self.data["equipped"].get(category) == item_id
    def get_equipped(self, category): return self.data["equipped"].get(category)

    def _load_fonts(self):
        target_font = FONT_FILE_UA if loc.current_lang == "UA" else FONT_FILE_EN
        
        # Set font sizes based on language
        if loc.current_lang == "UA":
            s_big, s_med, s_small, s_tiny = 50, 30, 20, 16
        else:
            s_big, s_med, s_small, s_tiny = 70, 40, 30, 24

        try:
            self.FONT_BIG = pygame.font.Font(target_font, s_big)
            self.FONT_MEDIUM = pygame.font.Font(target_font, s_med)
            self.FONT_SMALL = pygame.font.Font(target_font, s_small)
            self.FONT_TINY = pygame.font.Font(target_font, s_tiny)
            logging.info(f"Loaded font for {loc.current_lang}: {target_font}")
        except Exception:
            logging.warning(f"Font {target_font} not found, using system fallback")
            self.FONT_BIG = pygame.font.SysFont("Arial", s_big, bold=True)
            self.FONT_MEDIUM = pygame.font.SysFont("Arial", s_med)
            self.FONT_SMALL = pygame.font.SysFont("Arial", s_small)
            self.FONT_TINY = pygame.font.SysFont("Arial", s_tiny)

    def _create_background(self):
        num_clouds = len(theme_mgr.themes["light"]["bg_elements"])
        self._waves_manager = ObjectManager[ProceduralWave]()
        for i in range(num_clouds): self._waves_manager.add(ProceduralWave(i))
        self._bg_stars = []
        for _ in range(NUM_BG_STARS):
            self._bg_stars.append({'pos': (random.randint(0, WIDTH), random.randint(0, HEIGHT)), 'radius': random.randint(1, 2)})

    def _load_audio(self):
        try:
            hight_path = self._sound_effect_paths.get("hight")
            if hight_path and os.path.exists(hight_path):
                 self._catch_sound = pygame.mixer.Sound(hight_path)
                 self._sound_channel_star = pygame.mixer.Channel(0)
            else: self._catch_sound = None; self._sound_channel_star = None
        except: self._catch_sound = None; self._sound_channel_star = None

    @measure_time
    def _load_all_note_sounds(self):
        """
        @brief Preloads all note sounds from the sound directory.
        @details Handles converting filenames like 'f-4' to 'f#4'.
        """
        # Load all files from sound folder
        if not os.path.exists(SOUND_FOLDER):
            logging.error(f"Folder {SOUND_FOLDER} not found!")
            return

        for filename in os.listdir(SOUND_FOLDER):
            if filename.endswith(".ogg"):
                note_name = os.path.splitext(filename)[0] # e.g. "f-4"
                full_path = os.path.join(SOUND_FOLDER, filename)
                try:
                    sound = pygame.mixer.Sound(full_path)
                    
                    # 1. Save as is (e.g., "f-4")
                    self.sound_bank[note_name] = sound
                    
                    # 2. Auto-fix: if '-' is in name, save duplicate with '#'
                    if '-' in note_name:
                        sharp_name = note_name.replace('-', '#') # f-4 -> f#4
                        self.sound_bank[sharp_name] = sound
                        
                except Exception as e:
                    logging.error(f"Failed to load note: {filename}, {e}")
        logging.info(f"Loaded {len(self.sound_bank)} note sounds.")

    def play_note_sound(self, note_name):
        sound = self.sound_bank.get(note_name)
        
        if sound:
            sound.set_volume(self.sfx_volume)
            sound.play()
        else:
            logging.debug(f"Note sound not found: {note_name}")

    def play_catch_sound(self):
        if self._sound_channel_star and self._catch_sound:
            self._catch_sound.set_volume(self.sfx_volume)
            self._sound_channel_star.play(self._catch_sound)

    def play_music(self, music_path: str, fade_ms: int = 1000, volume: float = 0.5):
        if not os.path.exists(music_path): self._current_music_path = None; return
        if music_path == self._current_music_path and pygame.mixer.music.get_busy():
            pygame.mixer.music.set_volume(volume); return
        if pygame.mixer.music.get_busy(): pygame.mixer.music.fadeout(fade_ms)
        try:
            pygame.mixer.music.load(music_path)
            pygame.mixer.music.set_volume(volume)
            pygame.mixer.music.play(-1, fade_ms=fade_ms)
            self._current_music_path = music_path
        except: self._current_music_path = None

    def run(self):
        """ @brief Main Game Loop. """
        while self._running:
            dt = self._clock.tick(FPS) / 1000.0
            switched = theme_mgr.update()
            self._handle_events()
            self._update(dt, theme_switched=switched)
            self._draw()
        pygame.quit()

    def _handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT: self.stop()
            self._current_state.handle_event(event)

    def _update(self, dt, theme_switched=False):
        self._waves_manager.update_all(dt, theme_switched=theme_switched)
        self._current_state.update(dt)

    def _draw(self):
        self._window.fill(theme_mgr.get("bg_color"))
        if theme_mgr.get("has_bg_stars"):
            for star in self._bg_stars: pygame.draw.circle(self._window, WHITE, star['pos'], star['radius'])
        self._waves_manager.draw_all(self._window)
        self._current_state.draw(self._window)
        theme_mgr.draw_transition(self._window)
        pygame.display.flip()

    def change_state(self, new_state: GameState):
        """
        @brief Switches the current game state.
        @param new_state The new GameState instance to switch to.
        """
        self._current_state = new_state
        if isinstance(new_state, (MenuState, SettingsState, GameOverState, RhythmSelectionState, ShopState)):
             self.play_music(self._menu_music_path, volume=pygame.mixer.music.get_volume())
        elif isinstance(new_state, PlayingState):
            self.play_music(self._game_music_path, volume=0.3)

    def stop(self): self._running = False
    def get_settings(self) -> dict: return self._settings

# --- UNIT TESTS (Requirement: Unit Tests) ---
class TestRetinalSystems(unittest.TestCase):
    """
    @brief Unit tests for Game Logic, Localization, and Economy systems.
    @details Validates core functionality without launching the GUI.
    """
    def setUp(self):
        """ @brief Helper to initialize Game logic before each test. """
        # We start the game in headless mode to avoid window creation
        self.game = Game(headless=True)
        # Reset localization for isolation
        loc.current_lang = "EN"

    def test_localization_defaults(self):
        """ @brief Test that default language is EN and keys exist. """
        self.assertEqual(loc.current_lang, "EN")
        self.assertEqual(loc.get("START"), "START")
    
    def test_localization_toggle(self):
        """ @brief Test switching languages. """
        loc.toggle_lang()
        self.assertEqual(loc.current_lang, "UA")
        self.assertEqual(loc.get("START"), "ГРАТИ")
        
        loc.toggle_lang()
        self.assertEqual(loc.current_lang, "EN")

    def test_theme_manager(self):
        """ @brief Test theme switching logic. """
        theme_mgr.current_theme = "dark"
        theme_mgr.start_transition()
        self.assertTrue(theme_mgr.is_transitioning)
        self.assertEqual(theme_mgr.target_theme, "light")

    def test_economy_add_currency(self):
        """ @brief Test adding currency works. """
        initial = self.game.get_currency()
        self.game.add_currency(500)
        self.assertEqual(self.game.get_currency(), initial + 500)

    def test_economy_buy_item_success(self):
        """ @brief Test buying an item with sufficient funds. """
        self.game.data["currency"] = 1000
        result = self.game.buy_item("color", "TestBlue", 500)
        self.assertTrue(result)
        self.assertEqual(self.game.get_currency(), 500)
        self.assertTrue(self.game.has_item("color", "TestBlue"))

    def test_economy_buy_item_fail(self):
        """ @brief Test buying an item with insufficient funds. """
        self.game.data["currency"] = 10
        result = self.game.buy_item("color", "ExpensiveGold", 500)
        self.assertFalse(result)
        self.assertEqual(self.game.get_currency(), 10)
        self.assertFalse(self.game.has_item("color", "ExpensiveGold"))

    def test_highscore_update(self):
        """ @brief Test high score logic. """
        self.game.data["high_score"] = 100
        self.game.update_high_score(50)
        self.assertEqual(self.game.get_high_score(), 100) # Should not change
        self.game.update_high_score(200)
        self.assertEqual(self.game.get_high_score(), 200) # Should update

if __name__ == "__main__":
    # Check if we want to run tests via command line arg or simple flag
    if len(sys.argv) > 1 and sys.argv[1] == "test":
        # Remove the argument so unittest doesn't get confused
        sys.argv.pop(1)
        unittest.main()
    else:
        game = Game()
        game.run()